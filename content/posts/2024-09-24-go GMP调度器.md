---
description: ""
categories: [bagu]
title: golang GMPè°ƒåº¦å™¨
---

>[!note]
>æœ¬æ–‡åŸºäºgo1.21.2ï¼Œä¸åŒç‰ˆæœ¬çš„goå¯èƒ½ä¼šæœ‰å·®å¼‚ã€‚æ–‡ä¸­éƒ¨åˆ†ä»£ç ä¼šç”±äºä¸æ˜¯çŸ¥è¯†ç‚¹å¼ºç›¸å…³è€Œçœç•¥ï¼Œä½†è¢«å¿½ç•¥çš„æ¯è¡Œä»£ç æˆ–å¤šæˆ–å°‘éƒ½æœ‰å®ƒä»¬å®é™…çš„ç”¨å¤„ï¼Œç”šè‡³å¯èƒ½ä¸å®œåˆ é™¤ï¼Œæ¬¢è¿æŒ‡å‡º

> [!tip]
> åˆ†æåº•å±‚çš„ç›¸å…³çš„ä»£ç æ—¶ï¼Œå¾€å¾€ä¼šç”±äºå¹³å°æ¶æ„è€Œå¸¦æ¥ä»£ç ä¸Šçš„å·®å¼‚ï¼Œæ¯”å¦‚æˆ‘æœºå™¨æ˜¯darwin/arm64ï¼Œä½¿ç”¨vscodeæŸ¥çœ‹ä»£ç ï¼Œè€Œä¸”æˆ‘å¸Œæœ›åŸºäºlinux/amd64æ¥çœ‹ä»£ç ï¼Œå¯ä»¥åœ¨`.vscode/settings.json`ä¸­è®¾ç½®`GOOS`å’Œ`GOARCH`ï¼š
>
> ```json
> {
>  "go.toolsEnvVars": {
>      "GOOS": "linux",
>      "GOARCH": "amd64"
>  }
> }
> ```
>
> è¿™æ ·æˆ‘åœ¨æ‰“å¼€å¹³å°ç›¸å…³çš„ä»£ç æ–‡ä»¶æ¯”å¦‚`os_linux.go`æ—¶ï¼Œgoæ’ä»¶å°±èƒ½æ”¯æŒä»£ç è·³è½¬



![å›¾ç‰‡](https://cdn.jsdelivr.net/gh/NOS-AE/assets@main/img/640-20240924140244365)

## goè°ƒåº¦å™¨å‘å±•å†å²

go1.0.1åï¼Œ2012 å¹´ Google çš„å·¥ç¨‹å¸ˆ Dmitry Vyukov æå‡ºGMPæ¨¡å‹ä»¥åŠåŸºäºPçš„work-stealingæ¥æ”¹è¿›åŸæ¥çš„G-Må¤šçº¿ç¨‹æ¨¡å‹ã€‚

ä½†å°±ç®—æœ‰äº†GMPæ¨¡å‹ï¼Œç¨‹åºä¾ç„¶è¦ä¾é Gä¸»åŠ¨è®©å‡ºCPUæ‰èƒ½è§¦å‘è°ƒåº¦ï¼ˆæ­£å¸¸ç»“æŸæˆ–è€…`runtime.GoSched`ï¼‰

go1.2å¼•å…¥**åŸºäºåä½œçš„æŠ¢å å¼è°ƒåº¦**æ¥è§£å†³ï¼š

1. Gé•¿æ—¶é—´å ç”¨å¯¼è‡´å…¶ä»–Gé¥¥é¥¿
2. åƒåœ¾å›æ”¶STWæ—¶é—´è¿‡é•¿ï¼Œå¯¼è‡´æ•´ä¸ªç¨‹åºæ— æ³•å·¥ä½œ

ç¼–è¯‘å™¨ä¼šåœ¨å‡½æ•°è°ƒç”¨å‰æ’å…¥`runtime.morestack`ï¼Œè¿™ä¸ªå‡½æ•°å¯èƒ½ä¼šè°ƒç”¨`runtime.newstack`ï¼Œå…¶ä¸­ä¼šæ£€æŸ¥Gçš„`stackguard0`ä¸º`StackPreempt`çš„è¯ï¼Œè®©å‡ºå½“å‰çº¿ç¨‹ã€‚å› æ­¤åŸºäºåä½œçš„æŠ¢å è°ƒåº¦ä¸ºï¼š

1. ç¼–è¯‘å™¨åœ¨å‡½æ•°è°ƒç”¨å‰æ’å…¥`runtime.morestack`
2. è¿è¡Œæ—¶ä¼šåœ¨STWæˆ–è€…ç³»ç»Ÿç›‘æ§å‘ç°Gè¿ç»­è¿è¡Œè¶…è¿‡10msæ—¶å‘å‡ºæŠ¢å è¯·æ±‚ï¼Œå°†Gçš„`stackguard0`è®¾ç½®ä¸º`StackPreempt`
3. å‘ç”Ÿå‡½æ•°è°ƒç”¨æ—¶`runtime.morestack`ä¸­æ£€æŸ¥æ˜¯å¦æœ‰æŠ¢å è¯·æ±‚å¹¶è®©å‡ºçº¿ç¨‹

go1.14å¼•å…¥**åŸºäºå¼‚æ­¥ä¿¡å·çš„çœŸæŠ¢å å¼è°ƒåº¦**ï¼Œç›®å‰åªæœ‰STWå’Œæ ˆæ‰«æä¼šå‘èµ·æŠ¢å ä¿¡å·ï¼š

1. ç¨‹åºå¯åŠ¨æ—¶æ³¨å†Œ`SIGURG`ä¿¡å·çš„å¤„ç†å‡½æ•°`runtime.doSigPreempt`
2. åœ¨GCå’Œæ ˆæ‰«æçš„æ—¶å€™å°†å¤„äº`_Grunnable`çŠ¶æ€çš„Gæ ‡è®°æˆå¯æŠ¢å å¹¶å‘çº¿ç¨‹å‘é€`SIGURG`ä¿¡å·
3. `runtime.doSigPreempt`å°†ä¿®æ”¹`pc`è·³è½¬å›ç”¨æˆ·æ€æ‰§è¡Œ`runtime.asyncPreempt`
4. `runtime.asyncPreempt`ä¿å­˜ç”¨æˆ·å¯„å­˜å™¨ï¼Œå°†å½“å‰Gçš„çŠ¶æ€ä¸º`_Gpreempted`ï¼Œè°ƒç”¨`runtime.schedule`è®©Gé™·å…¥ä¼‘çœ å¹¶è®©å‡ºçº¿ç¨‹ï¼Œè°ƒåº¦å™¨è°ƒåº¦å…¶ä»–Gè¿è¡Œ

## bootstrap

golangç¨‹åºä»£ç çš„è¿è¡Œç¦»ä¸å¼€è¿›ç¨‹ã€çº¿ç¨‹ä»¥åŠgoroutineè¿™äº›æ¦‚å¿µï¼Œè€Œæ— è®ºæ˜¯ä»€ä¹ˆç¨‹åºéƒ½ä»ç¬¬ä¸€è¡Œä»£ç /æŒ‡ä»¤å¼€å§‹æ‰§è¡Œï¼Œæ‰€ä»¥æˆ‘æ‰“ç®—ä»æ•´ä¸ªç¨‹åºçš„ç¬¬ä¸€è¡Œæ±‡ç¼–æŒ‡ä»¤çš„æ‰§è¡Œå¼€å§‹è¯´èµ·ï¼Œå¦å¤–æˆ‘ä»¬ç»å¸¸è¯´åˆ°çš„g0ã€m0å…¶å®æ˜¯åœ¨å…¥å£æ±‡ç¼–ä»£ç ä¸­åˆå§‹åŒ–çš„ï¼Œæ‰€ä»¥æ›´æœ‰å¿…è¦ä»å¤´è®²èµ·ã€‚ä¸è¿‡ä¸ä¼šå¤ªæ·±å…¥ï¼Œå› ä¸ºå¾ˆå¤šçŸ¥è¯†æˆ‘ä¹Ÿåªæ˜¯æœ‰ä¸ªæ¦‚å¿µï¼Œæ¬¢è¿æŒ‡å‡ºè°¬è¯¯ã€‚

æ¯ä¸ªå¹³å°æ¶æ„çš„ä»£ç ä¼šæœ‰åŒºåˆ«ï¼Œæˆ‘è¿™è¾¹çš„ç¯å¢ƒä¸º`GOOS=linux,GOARCH=arm64`ï¼Œä¸åŒæ¶æ„çš„è¿è¡Œæµç¨‹å¤§åŒå°å¼‚ã€‚

å‚è€ƒæŸä½åšä¸»çš„åšå®¢ï¼Œäº†è§£åˆ°äº†delveè¿™ä¸ªå¥½ç”¨çš„ä¸œè¥¿ï¼Œåœ¨æˆ‘çœ‹æ¥delveæ˜¯ç”¨äºgoçš„gdbè°ƒè¯•å™¨ï¼Œå¯ä»¥æ±‡ç¼–æŒ‡ä»¤å•æ­¥è°ƒè¯•ã€‚ä¸‹é¢ç”¨å®ƒæ¥æ‰§è¡Œä¸€æŠŠè¿™ä¸ªhello worldç¨‹åºï¼Œçœ‹çœ‹ç¨‹åºçš„å…¥å£ä»£ç ï¼š

![image-20240918121018771](https://cdn.jsdelivr.net/gh/NOS-AE/assets@main/img/image-20240918121018771.png)

å¯ä»¥çœ‹åˆ°å…¥å£å‡½æ•°`_rt0_arm64_linux`å…¶å®æ˜¯ç›´æ¥å»åˆ°äº†`main`å‡½æ•°ï¼ˆæ±‡ç¼–ä¸­å®šä¹‰çš„mainå‡½æ•°ï¼Œå¦‚æœæ˜¯goä¸­çš„mainé€šå¸¸ä¼šåŠ åŒ…åå‰ç¼€`runtimeÂ·`ï¼Œæ¯”å¦‚`runtime.main`åœ¨æ±‡ç¼–ä¸­æ˜¯`runtimeÂ·main`ï¼‰ï¼š

```nasm
TEXT main(SB),NOSPLIT|NOFRAME,$0
	; è·³è½¬åˆ°runtimeÂ·rt0_goä»£ç æ®µ
	MOVD	$runtimeÂ·rt0_go(SB), R2
	BL	(R2)
exit:
	MOVD $0, R0
	MOVD	$94, R8	// sys_exit
	SVC
	B	exit
```
{: file='runtime/rt0_linux_arm64.s'}

å¯ä»¥çœ‹åˆ°è¿™ä¸ªå‡½æ•°ä¹Ÿåªæ˜¯è·³åˆ°äº†å¦ä¸€ä¸ªå‡½æ•°`runtimeÂ·rt0_go`ï¼Œè¿”å›ä¹‹åè°ƒç”¨äº†ç³»ç»Ÿè°ƒç”¨`sys_exit`é€€å‡ºç¨‹åºã€‚`runtimeÂ·rt0_go`å‡½æ•°åœ¨`asm_arm64.s`æ–‡ä»¶ä¸­ï¼Œè¿™ä¸ªå‡½æ•°è¿˜æ¶‰åŠåˆ°å¯åŠ¨å‚æ•°çš„åˆå§‹åŒ–ï¼š

```nasm
TEXT runtimeÂ·rt0_go(SB),NOSPLIT|TOPFRAME,$0
	; å°†å¯åŠ¨å‚æ•°æ”¾åˆ°æ ˆä¸­ï¼Œä¸‹é¢ä¼šæ‹¿å‡ºæ¥ç”¨
	SUB	$32, RSP
	MOVW	R0, 8(RSP) // argc
	MOVD	R1, 16(RSP) // argv

	...

	; åˆå§‹åŒ–g0ï¼Œå¯¹åº”proc.goä¸­å®šä¹‰çš„g0å˜é‡
	MOVD	$runtimeÂ·g0(SB), g

	...

	; åˆå§‹åŒ–m0ï¼Œå¯¹åº”proc.goä¸­çš„m0å˜é‡
	MOVD	$runtimeÂ·m0(SB), R0

	; ç»‘å®šg0å’Œm0
	MOVD	g, m_g0(R0)
	MOVD	R0, g_m(g)

	BL	runtimeÂ·check(SB)

	; è°ƒç”¨runtime.argsï¼Œä¿å­˜å¯åŠ¨å‚æ•°åˆ°argcå’Œargvå˜é‡ä¸­
	MOVW	8(RSP), R0	// copy argc
	MOVW	R0, -8(RSP)
	MOVD	16(RSP), R0		// copy argv
	MOVD	R0, 0(RSP)
	BL	runtimeÂ·args(SB)
	
	; è°ƒç”¨runtime.osinitåˆå§‹åŒ–ncpuå’Œç‰©ç†é¡µå¤§å°ã€è¿˜æœ‰å…¶ä»–çš„åˆå§‹åŒ–æ“ä½œ
	BL	runtimeÂ·osinit(SB)
	
	; è°ƒç”¨runtime.schedinitåˆå§‹åŒ–è°ƒåº¦å™¨
	; å…¶ä¸­ä¼šè°ƒç”¨goargså‡½æ•°å°†ä¸Šé¢ä¿å­˜çš„argcå’Œargvè§£ææˆå­—ç¬¦ä¸²ï¼Œä¿å­˜åˆ°argsliceå˜é‡ï¼Œæä¾›ç»™os.Argsä¾›ç”¨æˆ·ä½¿ç”¨
	BL	runtimeÂ·schedinit(SB)

	; è°ƒç”¨runtime.newprocï¼Œåˆ›å»ºä¸€ä¸ªgoroutineæ¥æ‰§è¡Œruntime.mainå‡½æ•°ï¼Œç”¨æˆ·çš„mainå°±æ˜¯ç”±è¿™ä¸ªruntime.mainè°ƒç”¨çš„
	MOVD	$runtimeÂ·mainPC(SB), R0		// entry
	SUB	$16, RSP
	MOVD	R0, 8(RSP) // arg
	MOVD	$0, 0(RSP) // dummy LR
	BL	runtimeÂ·newproc(SB)
	ADD	$16, RSP

	; è°ƒç”¨runtime.mstartå¼€å§‹è°ƒåº¦å™¨çš„å¾ªç¯è°ƒåº¦ï¼Œmstartåº”è¯¥æ˜¯ä¸ä¼šè¿”å›çš„ï¼Œä¸ç„¶å°±ä¼šæ‰§è¡Œä¸‹é¢çš„...boom!å¼‚å¸¸é€€å‡º
	BL	runtimeÂ·mstart(SB)

	MOVD	$runtimeÂ·debugCallV2<ABIInternal>(SB), R0

	MOVD	$0, R0
	MOVD	R0, (R0)	; boom
	UNDEF
	
DATA	runtimeÂ·mainPC+0(SB)/8,$runtimeÂ·main<ABIInternal>(SB)
GLOBL	runtimeÂ·mainPC(SB),RODATA,$8
```
{: file='runtime/asm_arm64.s'}

ä¸Šé¢è¿™æ®µæ±‡ç¼–ä»£ç å°±æ˜¯æ•´ä¸ªç¼–è¯‘å‡ºæ¥å¾—åˆ°çš„äºŒè¿›åˆ¶æ–‡ä»¶æœ€å¼€å§‹æ‰§è¡Œçš„ä»£ç ï¼Œä¸»è¦å¹²äº†ä¸‹é¢å‡ ä»¶äº‹ï¼š

1. åˆå§‹åŒ–å¯åŠ¨å‚æ•°
2. åˆå§‹åŒ–å¹¶ç»‘å®šg0å’Œm0ç»“æ„ä½“
3. åˆå§‹åŒ–oså’Œè°ƒåº¦å™¨
4. åˆ›å»ºä¸€ä¸ªæ–°çš„gå»è¿è¡Œruntime.main
5. è°ƒç”¨`runtime.mstart`å¼€å§‹è°ƒåº¦å¾ªç¯

æˆ‘ä»¬ä¸»è¦å…³æ³¨å¦‚ä½•åˆå§‹åŒ–è°ƒåº¦å™¨ã€å¦‚ä½•åˆ›å»ºgã€å¦‚ä½•è°ƒåº¦å¾ªç¯ã€‚é¦–å…ˆæ˜¯`runtime.schedinit`ã€‚

## åˆå§‹åŒ–è°ƒåº¦å™¨

```go
func schedinit() {
	...
    // è·å–g0
	gp := getg()
    ...
    // è®¾ç½®æœ€å¤§mæ•°é‡ä¸º10000
	sched.maxmcount = 10000
    ...

    // åˆå§‹åŒ–m0å¹¶æ·»åŠ åˆ°allmä¸­
    mcommoninit(gp.m, -1)
	...
    // åˆå§‹åŒ–gc
    gcinit()

    // è°ƒæ•´pçš„æ•°é‡ä¸ºGOMAXPROCS
	procs := ncpu
	if n, ok := atoi32(gogetenv("GOMAXPROCS")); ok && n > 0 {
		procs = n
	}
	if procresize(procs) != nil {
		throw("unknown runnable goroutine during bootstrap")
	}
}
```
{: file='runtime/proc.go'}

è°ƒåº¦å™¨æœ¬èº«æ¶‰åŠåˆ°å¾ˆå¤šä¸œè¥¿ï¼Œæ¯”å¦‚gcã€stackã€cpuã€osç­‰ï¼Œæ‰€ä»¥`runtime.schedinit`ä¹Ÿè´Ÿè´£åˆå§‹åŒ–äº†ä¸€å¤§å †ä¸œè¥¿ï¼Œä¸è¿‡å¾ˆå¤šéƒ½æš‚æ—¶ä¸ç”¨ç®¡ï¼Œä¸»è¦çœ‹ä¸€ä¸‹`runtime.procresize`å¯¹`allp`çš„åˆå§‹åŒ–ã€‚

`runtime.procresize`ä¸»è¦æ˜¯è°ƒæ•´pçš„æ•°é‡ä¸º`nprocs`ï¼Œç»‘å®šm0å’Œp0ï¼Œæœ€åè¿”å›å¯ä»¥è¢«è°ƒåº¦çš„pï¼š

```go
func procresize(nprocs int32) *p {

	...

    // è°ƒæ•´allpå¤§å°ï¼Œä½¿å…¶èƒ½å®¹çº³nprocsä¸ªp
	if nprocs > int32(len(allp)) {
		lock(&allpLock)
		if nprocs <= int32(cap(allp)) {
			allp = allp[:nprocs]
		} else {
			nallp := make([]*p, nprocs)
			copy(nallp, allp[:cap(allp)])
			allp = nallp
		}
        
        ...
        
		unlock(&allpLock)
	}

	// åˆ›å»ºpå¹¶åˆå§‹åŒ–ï¼Œpçš„åˆå§‹åŒ–çŠ¶æ€ä¸º_Pgcstop
	for i := old; i < nprocs; i++ {
		pp := allp[i]
		if pp == nil {
			pp = new(p)
		}
		pp.init(i)
		atomicstorep(unsafe.Pointer(&allp[i]), unsafe.Pointer(pp))
	}

    // å¦‚æœmæ²¡æœ‰ç»‘å®špï¼Œæˆ–è€…å·²ç»ç»‘å®šçš„pæ˜¯éæ³•çš„ï¼ˆä¸‹æ ‡è¶…å‡ºnprocs-1ï¼‰
    // 1. å¦‚æœæ²¡æœ‰pæˆ–è€…péæ³•ï¼Œå°†må’Œpè§£ç»‘ï¼Œå¹¶å°†må’Œp0ç»‘å®š
    // 2. å¦åˆ™ï¼Œè¿™ä¸ªå·²ç»‘å®šçš„på¯ä»¥çœ‹æˆp0ï¼ˆä¸ä¸€å®šä¸‹æ ‡ä¸º0æ‰èƒ½æ˜¯p0ï¼Œåªæ˜¯è¿™ä¹ˆå«è€Œå·²ï¼‰
	gp := getg()
	if gp.m.p != 0 && gp.m.p.ptr().id < nprocs {
		gp.m.p.ptr().status = _Prunning
		gp.m.p.ptr().mcache.prepareForSweep()
	} else {
		if gp.m.p != 0 {
            ...
			gp.m.p.ptr().m = 0 // è§£ç»‘m0å’Œp
		}
		gp.m.p = 0
		pp := allp[0]
		pp.m = 0
		pp.status = _Pidle
		acquirep(pp) // ç»‘å®šm0å’Œp0
        ...
	}

    ...

    // é”€æ¯æ— ç”¨çš„pï¼ˆä¸‹æ ‡è¶…å‡ºnprocs-1çš„pï¼‰
	for i := nprocs; i < old; i++ {
		pp := allp[i]
		pp.destroy()
	}
    ...

    // å°†m0.pä¹‹å¤–çš„pçš„çŠ¶æ€éƒ½è®¾æˆç©ºé—²_Pidle
    // å°†æœ¬åœ°é˜Ÿåˆ—ä¸ºç©ºçš„pæ”¾åˆ°ç©ºé—²é“¾è¡¨
    // å°†å‰©ä¸‹çš„pï¼ˆæœ¬åœ°é˜Ÿåˆ—ä¸ä¸ºç©ºçš„pï¼‰è¿”å›ä½œä¸ºå°†è¦è¢«è°ƒåº¦çš„p
	var runnablePs *p
	for i := nprocs - 1; i >= 0; i-- {
		pp := allp[i]
		if gp.m.p.ptr() == pp {
			continue
		}
		pp.status = _Pidle
		if runqempty(pp) {
			pidleput(pp, now)
		} else {
			pp.m.set(mget())
			pp.link.set(runnablePs)
			runnablePs = pp
		}
	}
    
    ...
	return runnablePs
}
```

## åˆ›å»ºgoroutine

é™¤äº†åœ¨bootstrapçš„æ±‡ç¼–ä»£ç ä¸­ä¸»åŠ¨è°ƒç”¨`runtime.newproc`ä¹‹å¤–ï¼Œç”¨æˆ·ä»£ç çš„`go`å…³é”®å­—ä¹Ÿä¼šè¢«ç¼–è¯‘å™¨è½¬åŒ–å¯¹`runtime.newproc`çš„è°ƒç”¨ï¼Œæ‰€ä»¥æ— è®ºæ˜¯userçš„ä»£ç è¿˜æ˜¯runtimeçš„ä»£ç ï¼Œå…¶å®éƒ½æ˜¯æ”¾åœ¨gä¸­ç”±è°ƒåº¦å™¨æ¥è°ƒåº¦æ‰§è¡Œï¼Œä»è¿™ä¸ªå±‚é¢ä¸Šæ¥è¯´æ²¡æœ‰ä»€ä¹ˆåŒºåˆ«ã€‚

```go
func newproc(fn *funcval) {
	gp := getg()
	pc := getcallerpc()
    
    // åœ¨g0ï¼ˆç³»ç»Ÿæ ˆï¼‰ä¸Šè¿è¡Œ
	systemstack(func() {
        // åˆ›å»ºå¹¶åˆå§‹åŒ–gç»“æ„ä½“
		newg := newproc1(fn, gp, pc)

        // æ”¾å…¥å½“å‰qçš„æœ¬åœ°é˜Ÿåˆ—
		pp := getg().m.p.ptr()
		runqput(pp, newg, true)

        // å¦‚æœmainå·²ç»è¿è¡Œï¼Œå”¤é†’æ–°çš„på»è°ƒåº¦gã€‚å¯¹äºbootstrapä¸­è°ƒç”¨newprocçš„æ—¶å€™ï¼Œmainè¿˜æ²¡è¿è¡Œ
		if mainStarted {
			wakep()
		}
	})
}
```

çœ‹ä¸‹`runtime.newproc1`å°†å¦‚ä½•åˆ›å»ºæ–°çš„gï¼š

```go
func newproc1(fn *funcval, callergp *g, callerpc uintptr) *g {
	...
    
    // è·å–ä¸€ä¸ªä¼˜å…ˆçš„ç©ºé—²g
    // ç”¨gfgetä¼˜å…ˆä»pæœ¬åœ°ç©ºé—²é˜Ÿåˆ—ä¸­å–gï¼Œæœ¬åœ°é˜Ÿåˆ—æ²¡æœ‰å†ä»schedtå…¨å±€ç©ºé—²é˜Ÿåˆ—ä¸­å–
    // æœ¬åœ°é˜Ÿåˆ—å’Œå…¨å±€é˜Ÿåˆ—éƒ½æ²¡æœ‰çš„è¯å†ç”¨malgåˆ›å»ºä¸€ä¸ªæ–°çš„æ ˆå¤§å°ä¸º2Kçš„g
	mp := acquirem()
	pp := mp.p.ptr()
	newg := gfget(pp)
	if newg == nil {
		newg = malg(stackMin) // stackMin=2K
		...
	}
    	
    ...
	
    // åˆå§‹åŒ–g
	memclrNoHeapPointers(unsafe.Pointer(&newg.sched), unsafe.Sizeof(newg.sched))
	newg.sched.sp = sp
	newg.stktopsp = sp
    // éå¸¸é‡è¦ï¼è¿™è¡Œå’Œä¸‹é¢gostartcallfnè¿™è¡Œï¼Œå°†gè¦æ‰§è¡Œä»£ç çš„å…¥å£åœ°å€pcæœ€ç»ˆè®¾æˆfnï¼Œä»¥åŠæ‰§è¡Œå®Œæˆåè¦çš„ä¸€ä¸‹ä¸ªæ‰§è¡Œåœ°å€lræœ€ç»ˆè¢«è®¾æˆruntime.goexitçš„å…¥å£
    // lrè¢«è®¾æˆgoexitè¯´æ˜gæ‰§è¡Œç»“æŸåï¼Œä¼šè·³è½¬åˆ°goexitå»åšæˆ‘ä»¬çš„æ”¶å°¾å·¥ä½œ
	newg.sched.pc = abi.FuncPCABI0(goexit) + sys.PCQuantum // +PCQuantum so that previous instruction is in same function
	newg.sched.g = guintptr(unsafe.Pointer(newg))
	gostartcallfn(&newg.sched, fn)
	newg.parentGoid = callergp.goid
	newg.gopc = callerpc
	newg.ancestors = saveAncestors(callergp)
	newg.startpc = fn.fn
    
	...
    
    // å°†gæ”¹æˆrunnableçŠ¶æ€
	casgstatus(newg, _Gdead, _Grunnable)
	gcController.addScannableStack(pp, int64(newg.stack.hi-newg.stack.lo))

    // æ¯ä¸ªgéƒ½æœ‰ä¸€ä¸ªgoidæ¥å”¯ä¸€æ ‡è¯†gï¼Œgoidæ˜¯ä»schedt.goidgené€’å¢+1ç”Ÿæˆçš„ï¼Œä¸ºäº†å‡å¯¹schedt.goidgençš„å¹¶å‘è®¿é—®ï¼Œæ¯æ¬¡ç”Ÿæˆä¸€æ‰¹idç¼“å­˜åˆ°pä¸­
	if pp.goidcache == pp.goidcacheend {
		pp.goidcache = sched.goidgen.Add(_GoidCacheBatch)
		pp.goidcache -= _GoidCacheBatch - 1
		pp.goidcacheend = pp.goidcache + _GoidCacheBatch
	}
	newg.goid = pp.goidcache
	pp.goidcache++
	
    ...

	releasem(mp)

	return newg
}
```

`gp.sched`æ˜¯å¹²ä»€ä¹ˆçš„å‘¢ï¼Ÿæˆ‘ä»¬å°†gçœ‹æˆæ˜¯ä¸€ä¸ªç‹¬ç«‹çš„æ‰§è¡Œå•å…ƒï¼ˆå®é™…ä¸Šå°±æ˜¯è¿™æ ·çš„ï¼Œgoroutineå˜›ï¼‰ï¼Œé‚£ä¹ˆå°±æœ‰è‡ªå·±çš„ç¨‹åºè®¡æ•°å™¨pcã€æ ˆæŒ‡é’ˆspï¼Œè¿”å›åœ°å€lrç­‰ï¼Œéƒ½ä¿å­˜åœ¨`gp.sched`ä¸­ã€‚

å›åˆ°`runtime.newproc`ï¼Œgè¢«è·å–åˆ°ä¹‹åä¼šè°ƒç”¨`runtime.runqput`å°è¯•æ”¾å…¥pçš„æœ¬åœ°é˜Ÿåˆ—å½“ä¸­ï¼š

```go
func runqput(pp *p, gp *g, next bool) {
	...

    // å°†gæ”¾åˆ°q.runnextä¸­ï¼Œä½œä¸ºqé©¬ä¸Šä¼šè°ƒåº¦è¿è¡Œçš„g
	if next {
	retryNext:
		oldnext := pp.runnext
		if !pp.runnext.cas(oldnext, guintptr(unsafe.Pointer(gp))) {
			goto retryNext
		}
		if oldnext == 0 {
			return
		}
		gp = oldnext.ptr()
	}

retry:
    // å°†gæ”¾åˆ°pçš„æœ¬åœ°é˜Ÿåˆ—ï¼Œå¦‚æœæœ¬åœ°é˜Ÿåˆ—æ»¡äº†ï¼Œå°±æ”¾åˆ°å…¨å±€é˜Ÿåˆ—
	h := atomic.LoadAcq(&pp.runqhead)
	t := pp.runqtail
	if t-h < uint32(len(pp.runq)) {
		pp.runq[t%uint32(len(pp.runq))].set(gp)
		atomic.StoreRel(&pp.runqtail, t+1)
		return
	}
	if runqputslow(pp, gp, h, t) {
		return
	}
	goto retry
}
```

`p.runq`æ˜¯ä¸ªç¯å½¢é˜Ÿåˆ—ï¼Œ`p.runqhead`å’Œ`p.runqtail`æ˜¯å¤´å’Œå°¾çš„ä¸‹æ ‡ï¼Œä¸è¿‡è¿™é‡Œçš„ä¸‹æ ‡ç”¨æ³•æˆ‘è¿˜æ˜¯ç¬¬ä¸€æ¬¡è§ï¼Œæ„Ÿè§‰éå¸¸niceï¼Œç‰¹æ­¤è®°å½•ä¸€ä¸‹ï¼šä¸€èˆ¬æ¥è¯´ä¸‹æ ‡ä¼šç»´æŠ¤æˆä¸è¶…è¿‡æ•°ç»„çš„å¤§å°ï¼Œæ¯”å¦‚`p.runqtail`åˆ°è¾¾`len(p.runq)-1`åï¼Œä¸‹ä¸€ä¸ªå€¼åº”è¯¥æ˜¯0ï¼Œä½†è¿™é‡Œå¯¹headå’Œtailéƒ½åªä¼šé€’å¢ï¼Œä¸ä¼šä¸»åŠ¨åšå–ä½™å›ç»•ï¼Œåœ¨è®¿é—®æ•°ç»„çš„æ—¶å€™æ‰åšä¸ªå–ä½™å³å¯ã€‚å¦å¤–ä¸‹æ ‡æ˜¯æ— ç¬¦å·æ•°çš„è¯å°†éå¸¸æ–¹ä¾¿è·å–é˜Ÿåˆ—å¤§å°ï¼Œæ¯”å¦‚`p.runqhead`/`p.runqtail`éƒ½æ˜¯`uint32`ï¼Œå› ä¸ºæ•´æ•°æœ¬èº«ä¹Ÿä¼šæº¢å‡ºæœ€å¤§å€¼å›ç»•åˆ°0ï¼Œæ¯”å¦‚head=(2^32)-5, tail=4ï¼Œé‚£ä¹ˆæ­¤æ—¶é˜Ÿåˆ—å¤§å°é€šè¿‡å‡æ³•ç›´æ¥å¾—å‡ºtail-head=9ï¼Œéå¸¸å¥½ç”¨ï¼›ç›¸åå¦‚æœæ˜¯æœ‰ç¬¦å·æ•°`int32`ï¼Œæ­¤æ—¶head=(2^31)-5, tail=4ï¼Œè¦å¾—å‡ºé˜Ÿåˆ—å¤§å°å°±ç¨å¾®éº»çƒ¦äº›äº†ã€‚

å¦å¤–æ³¨æ„æœ¬åœ°é˜Ÿåˆ—æ•°æ®ç»“æ„æ˜¯å›ºå®šé•¿åº¦çš„åˆ‡ç‰‡ï¼Œè€Œå…¨å±€é˜Ÿåˆ—æ˜¯ä¸ªé“¾è¡¨ï¼Œå› ä¸ºå…¨å±€é˜Ÿåˆ—ä¸­gçš„æ•°é‡ååˆ†æ˜“å˜ï¼Œæ‰€æœ‰péƒ½èƒ½å¾€é‡Œé¢æ”¾gæˆ–å–gï¼Œç”¨é“¾è¡¨ç»„ç»‡çœ‹èµ·æ¥æ›´é€‚åˆã€‚

æœ€åå°±æ˜¯`runtime.wakep`å‡½æ•°ï¼Œå”¤é†’æ–°çš„på»è°ƒåº¦gï¼Œä¸è¿‡bootstrapè¿‡ç¨‹ä¸­mainè¿˜æ²¡å¯åŠ¨ï¼Œæ‰€ä»¥ä¸ä¼šè°ƒç”¨è¿™ä¸ªå‡½æ•°ï¼Œå¯ä»¥å…ˆæ”¾ç€ï¼Œç­‰ä¸‹å†æ¥åˆ†æï¼Œä¸‹é¢ç»§ç»­çœ‹bootstrapä¸­çš„ç¬¬ä¸‰æ­¥ï¼Œè°ƒåº¦å¾ªç¯

## è°ƒåº¦å¾ªç¯

ä¸Šé¢åˆå§‹åŒ–è°ƒåº¦å™¨å’Œåˆ›å»ºgoroutineéƒ½åªæ˜¯åˆå§‹åŒ–è°ƒåº¦å™¨ï¼Œå…¶å®è¿˜æ²¡çœŸæ­£å¼€å§‹ç”¨mæ¥è·‘ä»€ä¹ˆä»£ç ï¼Œæ±‡ç¼–ä¸­è°ƒç”¨çš„`runtimeÂ·mstart`æ‰æ˜¯çœŸæ­£å¯åŠ¨mï¼Œå»æ‰§è¡Œgçš„ä»£ç ã€‚`runtimeÂ·mstart`ä¹Ÿæ˜¯ç”¨æ±‡ç¼–å†™çš„ï¼Œå…¶å®æ˜¯è°ƒç”¨äº†ç”¨goå†™çš„`runtime.mstart0`ï¼š

```nasm
TEXT runtimeÂ·mstart(SB),NOSPLIT|TOPFRAME,$0
	BL	runtimeÂ·mstart0(SB)
	RET // not reached
```
{: file='runtime/asm_arm64.s'}

```go
func mstart0() {
	gp := getg()

    // åˆå§‹åŒ–g0çš„æ ˆ
	osStack := gp.stack.lo == 0
	if osStack {
		size := gp.stack.hi
		if size == 0 {
			size = 16384 * sys.StackGuardMultiplier
		}
		gp.stack.hi = uintptr(noescape(unsafe.Pointer(&size)))
		gp.stack.lo = gp.stack.hi - size + 1024
	}
	gp.stackguard0 = gp.stack.lo + stackGuard
	gp.stackguard1 = gp.stackguard0
    
    // å¯åŠ¨m
	mstart1()

	// Exit this thread.
	if mStackIsSystemAllocated() {
		// Windows, Solaris, illumos, Darwin, AIX and Plan 9 always system-allocate
		// the stack, but put it in gp.stack before mstart,
		// so the logic above hasn't set osStack yet.
		osStack = true
	}
	mexit(osStack)
}
```

`runtime.mstart0`ä¸»è¦å°±æ˜¯åˆå§‹åŒ–g0ç³»ç»Ÿæ ˆï¼Œè°ƒç”¨`runtime.mstart1`å»å¯åŠ¨mï¼Œæœ€ååšé€€å‡ºmçš„æ”¶å°¾å·¥ä½œï¼Œæ³¨æ„`runtime.mstart1`ä¸ä¼šè¿”å›ï¼Œåªæœ‰å½“gé”å®šäº†mçš„æ—¶å€™ï¼Œæ‰ä¼šç›´æ¥åœ¨gä¸Šæ‰§è¡Œï¼Œç„¶åè¿”å›è°ƒç”¨`runtime.mstart1`çš„é‚£è¡Œä»£ç çš„ä¸‹ä¸€è¡Œä»£ç ï¼Œæ‰§è¡Œ`runtime.mexit`ã€‚ç»§ç»­çœ‹`runtime.mstart1`ï¼š

```go
func mstart1() {
	gp := getg()

    // è°ƒåº¦éƒ½æ˜¯å‘ç”Ÿåœ¨ç³»ç»Ÿå †æ ˆä¸Šçš„ï¼Œå³g0ï¼Œæ‰€ä»¥è¦æ£€æŸ¥ä¸€ä¸‹
	if gp != gp.m.g0 {
		throw("bad runtimeÂ·mstart")
	}

    // ä¸‹é¢è°ƒç”¨çš„scheduleä¸ä¼šè¿”å›ï¼Œå› æ­¤è¿™é‡Œç”¨äº†ç±»ä¼¼å°¾è°ƒç”¨çš„æ‰‹æ®µï¼Œå°†mstart0ä¸­è°ƒç”¨mstart1é‚£è¡Œä»£ç çš„pcä¿å­˜èµ·æ¥ï¼Œåœ¨goexit0ä¸­ä¼šç›´æ¥å›åˆ°mstart0ä¸­å»è¿è¡Œmexitæ¥å®Œæˆmçš„é€€å‡ºã€‚
	gp.sched.g = guintptr(unsafe.Pointer(gp))
	gp.sched.pc = getcallerpc()
	gp.sched.sp = getcallersp()

    // åˆå§‹åŒ–ä¿¡å·å¤„ç†ç›¸å…³çš„ä¸œè¥¿
	asminit()
	minit()
	if gp.m == &m0 {
		mstartm0()
	}

    // æ‰§è¡Œmçš„èµ·å§‹å‡½æ•°
    // é€šè¿‡æŸ¥æ‰¾mstartfnåœ¨å“ªè¢«èµ‹å€¼å¯ä»¥å‘ç°ï¼Œm0æ˜¯æ²¡æœ‰mstartfnçš„
	if fn := gp.m.mstartfn; fn != nil {
		fn()
	}

    // å¦‚æœå½“å‰ä¸æ˜¯m0ï¼Œç»‘å®šmå’Œm.nextpã€‚m0æ¥è¯´æ˜¯æ²¡æœ‰pçš„ï¼Œæ‰€ä»¥ä¸ç”¨ç»‘å®š
	if gp.m != &m0 {
		acquirep(gp.m.nextp.ptr())
		gp.m.nextp = 0
	}
    
    // å¼€å§‹è°ƒåº¦
	schedule()
}
```

`runtime.mstart1`ä¸»è¦æ˜¯è®¾ç½®`g.sched`ã€åˆå§‹åŒ–ä¿¡å·å¤„ç†ã€æ‰§è¡Œmçš„èµ·å§‹å‡½æ•°`mstartfn`ã€‚å‰é¢åšäº†é‚£ä¹ˆå¤šå‡†å¤‡å·¥ä½œï¼Œ`runtime.schedule`æ‰æ˜¯çœŸæ­£åšè°ƒåº¦å·¥ä½œï¼š

```go
func schedule() {
	mp := getg().m

	...

    // å¦‚æœæœ‰gå¿…é¡»åœ¨å½“å‰mä¸Šæ‰§è¡Œï¼Œä¸èƒ½æœ‰å…¶ä»–gæ‰§è¡Œï¼Œé‚£ä¹ˆç›´æ¥æ‰§è¡Œé‚£ä¸ªgå°±è¡Œï¼Œä¸ç”¨è°ƒåº¦å…¶ä»–g
    // ä¸€èˆ¬åªæœ‰runtime.LockOSThreadè°ƒç”¨åï¼Œm.lockedgæ‰æœ‰å€¼
	if mp.lockedg != 0 {
		stoplockedm()
		execute(mp.lockedg.ptr(), false) // Never returns.
	}

	...

top:
	pp := mp.p.ptr()
	pp.preempt = false

	// ä¸€è‡´æ€§æ£€æŸ¥ï¼šå¦‚æœmå¤„äºè‡ªæ—‹çŠ¶æ€ï¼Œé‚£ä¹ˆpä¸åº”è¯¥æœ‰ç­‰å¾…è¢«è°ƒç”¨çš„g
    // å…³äºmçš„è‡ªæ—‹çŠ¶æ€ï¼Œåœ¨proc.goæ–‡ä»¶çš„å¼€å¤´æ³¨é‡Šæœ‰ä¸€æ®µè¯´æ˜ï¼šmä¸æ­£åœ¨æ‰§è¡Œä»»åŠ¡ï¼Œå¹¶ä¸”å½“æœ¬åœ°é˜Ÿåˆ—ã€å…¨å±€é˜Ÿåˆ—ã€netpollerä¹Ÿæ²¡æœ‰ä»»åŠ¡ã€‚
	if mp.spinning && (pp.runnext != 0 || pp.runqhead != pp.runqtail) {
		throw("schedule: spinning with local work")
	}

    // å¯»æ‰¾å¯è°ƒåº¦çš„gï¼Œé˜»å¡åœ¨è¿™é‡Œç›´åˆ°æ‰¾åˆ°g
	gp, inheritTime, tryWakeP := findRunnable()

    ...

	// å¦‚æœmæœ¬æ¥æ˜¯è‡ªæ—‹çŠ¶æ€ï¼ˆæ‰¾ä¸åˆ°gè¿è¡Œï¼‰ï¼Œç°åœ¨å·²ç»æ‰¾åˆ°gäº†ï¼Œå–æ¶ˆè‡ªæ—‹
    // å¹¶ä¸”å¦‚æœè¿™æ˜¯å”¯ä¸€ä¸€ä¸ªè‡ªæ—‹ä¸­çš„mï¼Œé‚£ä¹ˆå°†ä¼šå†å»å¯åŠ¨ä¸€ä¸ªmå»è®©ä»–è‡ªæ—‹ï¼ˆåŸå› è§"Worker thread parking/unparking"çš„æ³¨é‡Šï¼‰
	if mp.spinning {
		resetspinning()
	}

    ...

	// å¦‚æœè¢«è°ƒåº¦çš„gæ¯”è¾ƒç‰¹æ®Šï¼ˆæ¯”å¦‚gcã€traceç›¸å…³ï¼‰ï¼Œå”¤é†’æ–°çš„på»ä¸“é—¨å¤„ç†è¿™äº›ç‰¹æ®Šçš„g
	if tryWakeP {
		wakep()
	}
    
    // å¦‚æœgæŒ‡å®šåœ¨æŸä¸ªmä¸Šè¿è¡Œï¼Œå°†pè½¬ç§»åˆ°æŒ‡å®šçš„mä¸Šï¼Œç„¶åparké˜»å¡å½“å‰må»è¿è¡ŒæŒ‡å®šm
    // è¿è¡Œå®Œåå†æŠŠpæ‹¿å›æ¥ï¼Œé‡æ–°èµ°ä¸€éä¸Šé¢æµç¨‹
	if gp.lockedm != 0 {
		startlockedm(gp)
		goto top
	}

    // æ‰§è¡Œg
	execute(gp, inheritTime)
}
```

`runtime.schedule`ä¸»è¦æ˜¯è·å–gï¼Œç„¶åè°ƒ`runtime.execute`å»æ‰§è¡Œgã€‚è¿™é‡Œ`runtime.findrunnable`æ¯”è¾ƒå¤æ‚ï¼Œä½†æ˜¯ä¸å½±å“ä¸»æµç¨‹ï¼Œå›è¿‡å¤´å†åˆ†æï¼Œå¤§æ¦‚çŸ¥é“å®ƒä¼šä»æœ¬åœ°é˜Ÿåˆ—ã€å…¨å±€é˜Ÿåˆ—ã€netpollerè¿™äº›åœ°æ–¹å»è·å–gå°±å¯ä»¥äº†ã€‚ä¸‹é¢ç»§ç»­çœ‹`runtime.execute`ï¼š

```go
func execute(gp *g, inheritTime bool) {
	mp := getg().m

	...

	// ç»‘å®šmå’Œgï¼Œå°†gè®¾ç½®ä¸º_Grunning
	mp.curg = gp
	gp.m = mp
	casgstatus(gp, _Grunnable, _Grunning)
    ...
	if !inheritTime {
        // å¦‚æœæ˜¯æ–°çš„æ—¶é—´ç‰‡ï¼Œè®°å½•pçš„è°ƒåº¦æ¬¡æ•°+1
		mp.p.ptr().schedtick++
	}

    ...

    // å®Œæˆä»g0åˆ°gçš„åˆ‡æ¢
	gogo(&gp.sched)
}
```

`runtime.execute`ä¸­ï¼Œå‚æ•°`inheritTime`æ„æ€æ˜¯æ˜¯å¦ä½¿ç”¨gå‰©ä¸‹çš„æ—¶é—´ç‰‡ï¼Œå¦åˆ™å°±é‡æ–°è¿è¡Œä¸€ä¸ªå®Œæ•´çš„æ—¶é—´ç‰‡ï¼Œè¿™ä¸ªå‚æ•°æ˜¯`runtime.findrunnable`æ¥å†³å®šçš„ã€‚ç»§ç»­çœ‹é‡å¤´æˆ`runtime.gogo`ï¼Œè¿™ä¸ªå‡½æ•°æ˜¯ç”¨æ±‡ç¼–å†™çš„ï¼š

```nasm
TEXT runtimeÂ·gogo(SB), NOSPLIT|NOFRAME, $0-8
	MOVD	buf+0(FP), R5
	MOVD	gobuf_g(R5), R6
	MOVD	0(R6), R4	// make sure g != nil
	; è°ƒç”¨gogo<>(gobuf.g), gobufå°±æ˜¯ä¼ å…¥çš„gp.sched
	B	gogo<>(SB)

TEXT gogo<>(SB), NOSPLIT|NOFRAME, $0
	MOVD	R6, g
	; è°ƒç”¨runtimeÂ·save_gï¼Œå°†gä¿å­˜åˆ°tls
	BL	runtimeÂ·save_g(SB)

	; ä»g0åˆ‡æ¢åˆ°gçš„ä¸Šä¸‹æ–‡ï¼ˆæ ˆã€è¿”å›åœ°å€ç­‰ï¼‰
	MOVD	gobuf_sp(R5), R0
	MOVD	R0, RSP
	MOVD	gobuf_bp(R5), R29
	MOVD	gobuf_lr(R5), LR
	MOVD	gobuf_ret(R5), R0
	MOVD	gobuf_ctxt(R5), R26
	; æ¸…ç©ºgobufçš„ä¸Šè¿°å­—æ®µ
	MOVD	$0, gobuf_sp(R5)
	MOVD	$0, gobuf_bp(R5)
	MOVD	$0, gobuf_ret(R5)
	MOVD	$0, gobuf_lr(R5)
	MOVD	$0, gobuf_ctxt(R5)
	CMP	ZR, ZR // set condition codes for == test, needed by stack split
	; è·³è½¬åˆ°gobuf.pcå»æ‰§è¡Œ
	MOVD	gobuf_pc(R5), R6
	B	(R6)
```

ç»ˆäºæ‰¾åˆ°äº†ï¼Œè°ƒåº¦çš„å…³é”®å°±åœ¨äºæœ€åé‚£ä¸¤è¡Œï¼è·³è½¬åˆ°gçš„pcï¼è·³è½¬è¿‡å»æ‰§è¡Œå®Œæ¯•åï¼Œä¼šè·³è½¬åˆ°`gobuf.lr`ã€‚å…³äºpcå’Œlråœ¨ä¹‹å‰åˆ†æ`runtime.newproc`çš„æ—¶å€™å°±èƒ½æ‰¾åˆ°ï¼Œæˆªå‡ºæ¥çœ‹ä¸€ä¸‹ï¼š

```go
func newproc1(fn *funcval, callergp *g, callerpc uintptr) *g {
	...
    
    // éå¸¸é‡è¦ï¼è¿™è¡Œå’Œä¸‹é¢gostartcallfnè¿™è¡Œï¼Œå°†gè¦æ‰§è¡Œä»£ç çš„å…¥å£åœ°å€pcæœ€ç»ˆè®¾æˆfnï¼Œä»¥åŠæ‰§è¡Œå®Œæˆåè¦çš„ä¸€ä¸‹ä¸ªæ‰§è¡Œåœ°å€lræœ€ç»ˆè¢«è®¾æˆruntime.goexitçš„å…¥å£ï¼Œå³gæ‰§è¡Œç»“æŸåï¼Œä¼šè·³è½¬åˆ°goexitå»åšæˆ‘ä»¬çš„æ”¶å°¾å·¥ä½œ
	newg.sched.pc = abi.FuncPCABI0(goexit) + sys.PCQuantum // +PCQuantum so that previous instruction is in same function
	newg.sched.g = guintptr(unsafe.Pointer(newg))
	gostartcallfn(&newg.sched, fn)
    
    ...
}
```

è·³è½¬åˆ°pcåï¼Œå°±æ˜¯å»æ‰§è¡Œgçš„ä»£ç äº†ï¼Œæ‰§è¡Œå®Œä¹‹åï¼Œå°±ä¼šè·³è½¬åˆ°`runtime.goexit`ï¼Œè€è§„çŸ©ï¼Œæ²¡æœ‰å‡½æ•°ä½“å°±æ˜¯ç”¨æ±‡ç¼–å†™çš„ï¼Œå…¶å®æ˜¯ç›´æ¥è·³è½¬åˆ°`runtime.goexit1`ï¼š

```go
func goexit1() {
	...
	mcall(goexit0)
}
```

ä»£ç çœç•¥çš„éƒ¨åˆ†æ˜¯raceå’Œtraceç›¸å…³ï¼Œæˆ‘ä»¬å…³æ³¨`runtime.mcall(goexit0)`ï¼Œ`runtime.mcall`ä¹Ÿæ˜¯æ±‡ç¼–å†™çš„ï¼Œä½œç”¨æ˜¯åˆ‡æ¢åˆ°ä»gåˆ‡æ¢åˆ°g0å»æ‰§è¡Œfnï¼Œè¿™ä¸ªfnä¸ä¼šè¿”å›ï¼Œè€Œæ˜¯æœ€ç»ˆä¼šè°ƒç”¨`runtime.gogo`æ¥ç»§ç»­æ‰§è¡Œgã€‚

æ‰€ä»¥`runtime.goexit1`æ˜¯åˆ‡æ¢åˆ°g0ï¼ˆç³»ç»Ÿæ ˆï¼‰ä¸Šå»æ‰§è¡Œ`runtime.goexit0`ã€‚`runtime.goexit0`ï¼š

```go
func goexit0(gp *g) {
	mp := getg().m
	pp := mp.p.ptr()

    // å°†gçš„çŠ¶æ€è®¾ä¸º_Gdead
	casgstatus(gp, _Grunning, _Gdead)
    // gæ‰€ç”¨çš„æ ˆå¯è¢«gcæ‰«æå›æ”¶
	gcController.addScannableStack(pp, -int64(gp.stack.hi-gp.stack.lo))
    // è®¾ç½®ä¸€äº›å…¨å±€çŠ¶æ€ã€ç½®ç©ºgçš„ä¸€äº›æˆå‘˜
	if isSystemGoroutine(gp, false) {
		sched.ngsys.Add(-1)
	}
	gp.m = nil
	locked := gp.lockedm != 0
	gp.lockedm = 0
	mp.lockedg = 0
	gp.preemptStop = false
	gp.paniconfault = false
	gp._defer = nil // should be true already but just in case.
	gp._panic = nil // non-nil for Goexit during panic. points at stack-allocated data.
	gp.writebuf = nil
	gp.waitreason = waitReasonZero
	gp.param = nil
	gp.labels = nil
	gp.timer = nil

	...

    // è§£ç»‘må’Œg
	dropg()

	...

    // å°†gæ”¾å…¥pçš„ç©ºé—²é˜Ÿåˆ—ï¼Œä»¥ä¾¿ä¸‹æ¬¡å¯ä»¥é€šè¿‡runtime.gfgetå¤ç”¨ä¸ç”¨æ¯æ¬¡éƒ½åˆ›å»ºæ–°çš„g
	gfput(pp, gp)
    
    ...
    
    // è°ƒåº¦å¾ªç¯ï¼Œè°ƒåº¦ä¸‹ä¸€ä¸ªgè¿è¡Œ
	schedule()
}
```

ç»è¿‡ä¸Šé¢çš„ä¸€æ­¥æ­¥åˆ†æï¼Œã€Œæ•´ä¸ªç¨‹åºçš„å¯åŠ¨åˆ›å»ºg0->è·³è½¬åˆ°gå¹¶æ‰§è¡Œ->è°ƒåº¦ä¸‹ä¸€ä¸ªgæ‰§è¡Œã€å½¢æˆäº†ä¸€ä¸ªè°ƒåº¦å¾ªç¯çš„é—­ç¯ã€‚å®é™…æƒ…å†µä¼šæ›´åŠ å¤æ‚ï¼Œä¸Šé¢æ‰€è¯´çš„åªæ˜¯æ­£å¸¸è°ƒåº¦çš„æµç¨‹ï¼Œçœç•¥äº†å¾ˆå¤šåˆ†æ”¯æƒ…å†µï¼Œæ¯”å¦‚gåœ¨æ‰§è¡Œçš„è¿‡ç¨‹ä¸­ä¼šç»å†åä½œå¼æˆ–è€…æŠ¢å å¼è°ƒåº¦ï¼Œå®ƒä¼šè®©å‡ºçº¿ç¨‹çš„ä½¿ç”¨æƒç­‰å¾…è°ƒåº¦å™¨çš„å”¤é†’ã€‚

ä¸»æµç¨‹ä¸Šå…¶å®è¿˜æœ‰å¾ˆå¤šæ‚¬è€Œæœªå†³çš„é—®é¢˜ï¼š

1. ä¸ºäº†å……åˆ†åˆ©ç”¨å¤šæ ¸å¹¶è¡Œèƒ½åŠ›ï¼Œå¿…ç„¶è¦å¯åŠ¨å¤šä¸ªmï¼Œé‚£ä¹ˆmæ˜¯ä»€ä¹ˆæ—¶å€™å¯åŠ¨çš„ï¼Œè¿›ä¸€æ­¥åœ°è¯´ï¼Œmçš„ç”Ÿå‘½å‘¨æœŸæ˜¯æ€ä¹ˆæ ·çš„ï¼Ÿ
2. `runtime.findrunnable`å†³å®šäº†ä¸‹ä¸€ä¸ªè¦è¿è¡Œçš„gï¼Œæ˜¯è°ƒåº¦ç­–ç•¥çš„æ ¸å¿ƒï¼Œé‚£ä¹ˆä»–å°†å¦‚ä½•é€‰æ‹©gï¼Ÿ

å…ˆåˆ†æä¸‹mçš„ç”Ÿå‘½å‘¨æœŸï¼Œé¦–å…ˆmé€šè¿‡`runtime.startm`å¯åŠ¨ï¼Œè¿™ä¸ªå‡½æ•°åœ¨å¥½å‡ ä¸ªåœ°æ–¹ä¼šè¢«è°ƒç”¨ï¼š

- `runtime.handoffp`ï¼šå°†pä¸é˜»å¡çš„mè§£ç»‘ï¼Œå»å¯»æ‰¾éé˜»å¡çš„mç»‘å®š
- `runtime.wakep`ï¼šå”¤é†’på»è°ƒåº¦g
- `runtime.injectglist`ï¼šå°†ä¸€äº›å¯è¿è¡Œçš„gæ”¾åˆ°æœ¬åœ°é˜Ÿåˆ—/å…¨å±€é˜Ÿåˆ—ï¼Œè®©ä»–ä»¬å¾—ä»¥è°ƒåº¦è¿è¡Œ
- `runtime.sysmon`ï¼šç³»ç»Ÿç›‘æ§ï¼ŒåŒ…æ‹¬gcã€netpollã€preemptionç­‰
- `runtime.schedEnableUser`ï¼šgcæ—¶åœæ­¢è°ƒåº¦ç”¨æˆ·çš„g

å…¶ä¸­`runtime.handoffp`å¯ä»¥åœ¨syscallé˜»å¡mçš„æ—¶å€™æ‰è¿›è¡Œåˆ†æï¼Œ`runtime.injectglist`åœ¨å¥½å‡ ä¸ªåœ°æ–¹ä¹Ÿä¼šè¢«è°ƒç”¨ï¼ŒåŠŸèƒ½æ¯”è¾ƒé€šç”¨/æ³›åŒ–ï¼Œä¹Ÿæš‚æ—¶ä¸çœ‹ï¼Œ`runtime.sysmon`æ˜¯ç³»ç»Ÿç›‘æ§ç›¸å…³ï¼Œå¯ä»¥ä¸“é—¨æ”¾åˆ°ä¸€ä¸ªå°èŠ‚æ¥åˆ†æï¼Œæœ€å`runtime.schedEnableUser`æ˜¯gcç›¸å…³ï¼Œä¸æ˜¯è¿™é‡Œçš„é‡ç‚¹ã€‚ç›®å‰â€œæœ€ç†Ÿæ‚‰â€çš„æ˜¯`runtime.wakeup`ï¼Œè¿™ä¸ªå‡½æ•°åœ¨`runtime.newproc`å’Œ`runtime.schedule`éƒ½æœ‰è°ƒç”¨ï¼Œå› æ­¤å…ˆçœ‹ä¸€ä¸‹è¿™ä¸ª`runtime.wakep`ï¼š

```go
func wakep() {
    // å¦‚æœå·²ç»æœ‰è‡ªæ—‹çš„mï¼Œå°±ä»€ä¹ˆéƒ½ä¸åš
	if sched.nmspinning.Load() != 0 || !sched.nmspinning.CompareAndSwap(0, 1) {
		return
	}

	mp := acquirem()

	var pp *p
	lock(&sched.lock)
    // å°è¯•è·å–ä¸€ä¸ªç©ºé—²çš„p
	pp, _ = pidlegetSpinning(0)
	if pp == nil {
		if sched.nmspinning.Add(-1) < 0 {
			throw("wakep: negative nmspinning")
		}
		unlock(&sched.lock)
		releasem(mp)
		return
	}
	
	unlock(&sched.lock)

    // å¯åŠ¨m
	startm(pp, true, false)

	releasem(mp)
}
```

çœ‹èµ·æ¥`runtime.wakep`å¥½åƒæ²¡åšä»€ä¹ˆï¼Œåªæ˜¯å»è·å–äº†ä¸€ä¸ªç©ºé—²pç„¶åä¼ ç»™`runtime.startm`ã€‚ç»§ç»­çœ‹`runtime.startm`

```go
func startm(pp *p, spinning, lockheld bool) {
	...
    
    // wakepä¼ è¿›æ¥çš„ppä¸ä¼šæ˜¯nilï¼Œæš‚æ—¶å¿½ç•¥pp==nilçš„å¤„ç†
	if pp == nil {
		...
	}
    
    // ä»å…¨å±€mç©ºé—²é“¾è¡¨è·å–ä¸€ä¸ªç©ºé—²çš„mï¼Œå¦‚æœè·å–ä¸åˆ°ï¼Œè°ƒç”¨runtime.newmåˆ›å»ºæ–°çš„m
	nmp := mget()
	if nmp == nil {
		...

		var fn func()
		if spinning {
			// The caller incremented nmspinning, so set m.spinning in the new M.
			fn = mspinning
		}
        // åˆ›å»ºm
		newm(fn, pp, id)

		...
		return
	}
	...
	// å”¤é†’è¿™ä¸ªç©ºé—²çš„m
	nmp.spinning = spinning
	nmp.nextp.set(pp)
	notewakeup(&nmp.park)
	releasem(mp)
}
```

æ‰€ä»¥`runtime.wakep`æ˜¯å”¤é†’ä¸€ä¸ªpå¹¶å”¤é†’/åˆ›å»ºä¸€ä¸ªmï¼Œmä¼šå¤„äºè‡ªæ—‹çŠ¶æ€ï¼Œè‡ªæ—‹çš„mä¼šå»æ‰¾pç»‘å®šã€‚ç»§ç»­çœ‹`runtime.newm`æ˜¯æ€ä¹ˆåˆ›å»ºmçš„ï¼š

```go
func newm(fn func(), pp *p, id int64) {
	acquirem()

    // åˆ›å»ºä¸€ä¸ªmç»“æ„ä½“
	mp := allocm(pp, fn, id)
	mp.nextp.set(pp)
	mp.sigmask = initSigmask
    
	...
    
    // åˆ›å»ºmå¯¹åº”çš„çº¿ç¨‹
	newm1(mp)
    
	releasem(getg().m)
}

func newm1(mp *m) {
    if iscgo {
		...
    }
    
	execLock.rlock() // Prevent process clone.
    // åˆ›å»ºç³»ç»Ÿçº¿ç¨‹
	newosproc(mp)
	execLock.runlock()
}
```

`runtime.newm`ä¸»è¦æ˜¯åˆ›å»ºmç»“æ„ä½“ï¼Œ`runtime.newm1`æ˜¯cgoç›¸å…³çš„å¤„ç†ä»£ç ï¼Œç„¶åè°ƒç”¨`runtime.newosproc`åˆ›å»ºç³»ç»Ÿçº¿ç¨‹ï¼š

```go
func newosproc(mp *m) {
	stk := unsafe.Pointer(mp.g0.stack.hi)
	...
    
    // å‘èµ·ç³»ç»Ÿè°ƒç”¨åˆ›å»ºç³»ç»Ÿçº¿ç¨‹è¿è¡Œruntime.mstart
	ret := retryOnEAGAIN(func() int32 {
		r := clone(cloneFlags, stk, unsafe.Pointer(mp), unsafe.Pointer(mp.g0), unsafe.Pointer(abi.FuncPCABI0(mstart)))
		// clone returns positive TID, negative errno.
		// We don't care about the TID.
		if r >= 0 {
			return 0
		}
		return -r
	})
	sigprocmask(_SIG_SETMASK, &oset, nil)

    // é”™è¯¯å¤„ç†
	if ret != 0 {
		print("runtime: failed to create new OS thread (have ", mcount(), " already; errno=", ret, ")\n")
        // linuxä¸ä¸¥æ ¼åŒºåˆ†è¿›ç¨‹å’Œçº¿ç¨‹ï¼Œè¿™é‡Œæ˜¯æç¤ºè®©æˆ‘ä»¬ç”¨ulimit -uæé«˜ç”¨æˆ·è¿›ç¨‹æ•°ä¸Šé™
		if ret == _EAGAIN {
			println("runtime: may need to increase max user processes (ulimit -u)")
		}
		throw("newosproc")
	}
}
```

çº¿ç¨‹åˆ›å»ºä¹‹åï¼Œä¼šå»è·‘`runtime.mstart`ï¼Œéšåå°±æ˜¯è¿›å…¥è°ƒåº¦å¾ªç¯äº†ï¼ˆä½†ä¹Ÿæœ‰çš„çº¿ç¨‹ä¸å‚ä¸è°ƒåº¦å·¥ä½œï¼Œè€Œæ˜¯å»åšåˆ«çš„å·¥ä½œï¼Œæ¯”å¦‚`runtime.sysmon`ï¼‰

ç»è¿‡ä¸€ç•ªçš„ä»£ç è·Ÿè¸ªï¼Œå¯¹æ•´ä¸ªè°ƒåº¦æµç¨‹æœ‰äº†ä¸ªå¤§æ¦‚çš„è®¤çŸ¥ï¼šé¦–å…ˆ`proc.go`é‡Œæœ‰å…¨å±€å˜é‡m0ï¼Œä½œä¸ºæˆ‘ä»¬æ•´ä¸ªç¨‹åºçš„ç¬¬ä¸€ä¸ªmï¼Œä»¥åŠä½œä¸ºm0çš„g0ï¼ˆæ³¨æ„æ¯ä¸ªméƒ½æœ‰è‡ªå·±çš„g0ï¼Œg0æ‰€å æœ‰çš„æ ˆå³ç³»ç»Ÿæ ˆï¼Œè°ƒåº¦è¡Œä¸ºæ˜¯å‘ç”Ÿåœ¨ç³»ç»Ÿæ ˆä¸Šçš„ï¼‰ã€‚è¿›å…¥bootstrapåï¼Œåˆ›å»ºäº†ç¬¬ä¸€ä¸ªgï¼Œè¿™ä¸ªgç”¨æ¥`runtime.main`ï¼Œåœ¨è¿™ä¸ªå‡½æ•°ä¸­ä¼šè¿›å…¥ç”¨æˆ·çš„`main`è¿è¡Œã€‚æ¯æ¬¡åˆ›å»ºæ–°çš„gï¼Œéƒ½å¯èƒ½ä¼šåˆ›å»ºæ–°çš„pçš„å’Œæ–°çš„mæ¥è°ƒåº¦è¿è¡Œgï¼Œæ¯ä¸ªméƒ½åœ¨è¿›è¡Œç€è‡ªå·±çš„è°ƒåº¦å¾ªç¯ã€‚è°ƒåº¦å¾ªç¯å¹¶ä¸æ˜¯æŒ‡`for`å¾ªç¯ï¼Œè€Œæ˜¯ä¸‹é¢çš„ä¸‰éƒ¨æ›²ï¼š

1. `schedule`ï¼šè´Ÿè´£è°ƒåº¦ç­–ç•¥ï¼Œå†³å®šä¸‹ä¸€ä¸ªè°ƒåº¦çš„g
2. `gogo`ï¼šæ‰§è¡Œä»g0åˆ‡æ¢åˆ°gå»æ‰§è¡Œï¼Œè®¾ç½®gçš„è¿”å›åœ°å€ä¸º`goexit`
3. `goexit`ï¼šæ¸…ç†è¿™ä¸ªæ‰§è¡Œå®Œæ¯•çš„gï¼Œè°ƒç”¨`schedule`è¿›è¡Œæ–°ä¸€è½®çš„è°ƒåº¦

## runtime.findrunnable

ä¸Šä¸ªå°èŠ‚ä¸»è¦ç”¨æ¥ç†æ¸…è°ƒåº¦å¾ªç¯ï¼Œè¿™ä¸ªå°èŠ‚æ”»å…‹è°ƒåº¦ç­–ç•¥çš„å®ç°ï¼Œå³`runtime.findrunnable`ï¼š

```go
func findRunnable() (gp *g, inheritTime, tryWakeP bool) {
	...

	// å°è¯•è·å–gc workerçš„g
	if gcBlackenEnabled != 0 {
		gp, tnow := gcController.findRunnableGCWorker(pp, now)
		if gp != nil {
			return gp, false, true
		}
		now = tnow
	}

	// æ¯è°ƒåº¦60æ¬¡å°±å°è¯•ä¸€æ¬¡è·å–å…¨å±€é˜Ÿåˆ—çš„gï¼Œä»¥å…ç”±äºå…¨å±€é˜Ÿåˆ—ä¼˜å…ˆçº§è¾ƒä½è€Œå¯¼è‡´å…¶ä¸­çš„gé¥¥é¥¿
	if pp.schedtick%61 == 0 && sched.runqsize > 0 {
		lock(&sched.lock)
		gp := globrunqget(pp, 1)
		unlock(&sched.lock)
		if gp != nil {
			return gp, false, false
		}
	}

	// å”¤é†’finalizerçš„g
	if fingStatus.Load()&(fingWait|fingWake) == fingWait|fingWake {
		if gp := wakefing(); gp != nil {
			ready(gp, 0, true)
		}
	}
	if *cgo_yield != nil {
		asmcgocall(*cgo_yield, nil)
	}

	// å°è¯•ä»æœ¬åœ°é˜Ÿåˆ—è·å–g
	if gp, inheritTime := runqget(pp); gp != nil {
		return gp, inheritTime, false
	}

	// å°è¯•ä»å…¨å±€é˜Ÿåˆ—è·å–g
	if sched.runqsize != 0 {
		lock(&sched.lock)
		gp := globrunqget(pp, 0)
		unlock(&sched.lock)
		if gp != nil {
			return gp, false, false
		}
	}

	// å°è¯•ä»netpollerè·å–ä¸€æ‰¹gï¼Œè¿”å›å…¶ä¸­ç¬¬ä¸€ä¸ªgï¼Œå…¶ä»–gæ”¾åˆ°é˜Ÿåˆ—ä¸­
	if netpollinited() && netpollWaiters.Load() > 0 && sched.lastpoll.Load() != 0 {
		if list := netpoll(0); !list.empty() { // non-blocking
			gp := list.pop()
			injectglist(&list)
			casgstatus(gp, _Gwaiting, _Grunnable)
			if traceEnabled() {
				traceGoUnpark(gp, 0)
			}
			return gp, false, false
		}
	}

    // å¦‚æœmå¤„äºè‡ªæ—‹æˆ–è€…è‡ªæ—‹çš„mç›¸å¯¹äºç©ºé—²çš„pä¸å¤Ÿå¤šï¼Œå°è¯•éšæœºä»å…¶ä»–pçš„æœ¬åœ°é˜Ÿåˆ—å·ä¸€åŠçš„gï¼ˆè¿™é‡Œtimeræ²¡ç†è§£æ˜¯ä»€ä¹ˆä¸œè¥¿ï¼Œä»¥åæœ‰æ—¶é—´å†çœ‹ï¼‰
	if mp.spinning || 2*sched.nmspinning.Load() < gomaxprocs-sched.npidle.Load() {
		if !mp.spinning {
			mp.becomeSpinning()
		}

		gp, inheritTime, tnow, w, newWork := stealWork(now)
		if gp != nil {
			// Successfully stole.
			return gp, inheritTime, false
		}
		if newWork {
			// There may be new timer or GC work; restart to
			// discover.
			goto top
		}

		now = tnow
		if w != 0 && (pollUntil == 0 || w < pollUntil) {
			// Earlier timer to wait for.
			pollUntil = w
		}
	}

	// åˆæ˜¯gc workerç›¸å…³çš„ï¼Œçœ‹ä¸æ‡‚ï¼Œä¸è¿‡è¿™æ¬¡çš„gä¸å†å±äºç‰¹æ®Šgï¼ˆtryWakep=falseï¼‰
	if gcBlackenEnabled != 0 && gcMarkWorkAvailable(pp) && gcController.addIdleMarkWorker() {
		node := (*gcBgMarkWorkerNode)(gcBgMarkWorkerPool.pop())
		if node != nil {
			pp.gcMarkWorkerMode = gcMarkWorkerIdleMode
			gp := node.gp.ptr()
			casgstatus(gp, _Gwaiting, _Grunnable)
			if traceEnabled() {
				traceGoUnpark(gp, 0)
			}
			return gp, false, false
		}
		gcController.removeIdleMarkWorker()
	}

	...

	// Before we drop our P, make a snapshot of the allp slice,
	// which can change underfoot once we no longer block
	// safe-points. We don't need to snapshot the contents because
	// everything up to cap(allp) is immutable.
	allpSnapshot := allp
	// Also snapshot masks. Value changes are OK, but we can't allow
	// len to change out from under us.
	idlepMaskSnapshot := idlepMask
	timerpMaskSnapshot := timerpMask

	// return P and block
	lock(&sched.lock)
	if sched.gcwaiting.Load() || pp.runSafePointFn != 0 {
		unlock(&sched.lock)
		goto top
	}
    // å†æ¬¡æ£€æŸ¥å…¨å±€é˜Ÿåˆ—ï¼Œå‘ç°æœ‰gå°±è¿”å›
	if sched.runqsize != 0 {
		gp := globrunqget(pp, 0)
		unlock(&sched.lock)
		return gp, false, false
	}
    // å¦‚æœéœ€è¦mè‡ªæ—‹ï¼Œé‚£ä¹ˆmå˜ä¸ºè‡ªæ—‹çŠ¶æ€ç„¶åå†èµ°ä¸€éæµç¨‹
	if !mp.spinning && sched.needspinning.Load() == 1 {
		// See "Delicate dance" comment below.
		mp.becomeSpinning()
		unlock(&sched.lock)
		goto top
	}
    // è§£ç»‘å½“å‰må’Œp
	if releasep() != pp {
		throw("findrunnable: wrong p")
	}
	now = pidleput(pp, now)
	unlock(&sched.lock)

	wasSpinning := mp.spinning
    // é¦–å…ˆå…³é—­mçš„è‡ªæ—‹ï¼Œå†æ¬¡æ£€æŸ¥æœ‰æ²¡æœ‰gå¯ä»¥å·çš„pï¼Œæœ‰çš„è¯å°±å†æ¬¡å˜ä¸ºè‡ªæ—‹çŠ¶æ€ç„¶åå†èµ°ä¸€éæµç¨‹
    // å¦åˆ™å»æ£€æŸ¥æœ‰æ²¡æœ‰ç©ºé—²gc workerï¼Œæœ‰çš„è¯å°±è¿”å›gc workerçš„g
	if mp.spinning {
		mp.spinning = false
		if sched.nmspinning.Add(-1) < 0 {
			throw("findrunnable: negative nmspinning")
		}

		pp := checkRunqsNoP(allpSnapshot, idlepMaskSnapshot)
		if pp != nil {
			acquirep(pp)
			mp.becomeSpinning()
			goto top
		}

		// Check for idle-priority GC work again.
		pp, gp := checkIdleGCNoP()
		if pp != nil {
			acquirep(pp)
			mp.becomeSpinning()

			// Run the idle worker.
			pp.gcMarkWorkerMode = gcMarkWorkerIdleMode
			casgstatus(gp, _Gwaiting, _Grunnable)
			if traceEnabled() {
				traceGoUnpark(gp, 0)
			}
			return gp, false, false
		}

		pollUntil = checkTimersNoP(allpSnapshot, timerpMaskSnapshot, pollUntil)
	}

	// å†æ¬¡å°è¯•ä»netpollerè·å–g
	if netpollinited() && (netpollWaiters.Load() > 0 || pollUntil != 0) && sched.lastpoll.Swap(0) != 0 {
		...
		list := netpoll(delay) // block until new work is available
        
        // å¦‚æœæ²¡è·å–åˆ°gï¼Œé‚£ä¹ˆmå°±ä¼‘çœ ï¼ˆå˜æˆç©ºé—²çš„mï¼‰
		if faketime != 0 && list.empty() {
			stopm()
			goto top // må”¤é†’åå†èµ°ä¸€éæµç¨‹
		}
		lock(&sched.lock)
		pp, _ := pidleget(now)
		unlock(&sched.lock)
		if pp == nil {
			injectglist(&list)
		} else {
			acquirep(pp)
			if !list.empty() {
                // å¦‚æœè·å–åˆ°äº†gå°±è¿”å›
				gp := list.pop()
				injectglist(&list)
				casgstatus(gp, _Gwaiting, _Grunnable)
				if traceEnabled() {
					traceGoUnpark(gp, 0)
				}
				return gp, false, false
			}
            
            
			if wasSpinning {
				mp.becomeSpinning()
			}
			goto top
		}
	} else if pollUntil != 0 && netpollinited() {
		pollerPollUntil := sched.pollUntil.Load()
		if pollerPollUntil == 0 || pollerPollUntil > pollUntil {
            // ä¸å¤ªç†è§£è¿™é‡Œï¼Œæˆ‘çŒœåº”è¯¥æ˜¯å·²ç»çŸ¥é“äº†netpollæ²¡æœ‰ä¸œè¥¿è¿”å›ï¼Œç›´æ¥è®©å…¶ä»–ä¹Ÿåœ¨ç­‰netpollçš„çº¿ç¨‹ä¹Ÿåˆ«ç­‰äº†
			netpollBreak()
		}
	}
    // mä¼‘çœ ï¼Œå”¤é†’åå†èµ°ä¸€éæµç¨‹
	stopm()
	goto top
}
```

é¦–å…ˆè‡ªæ—‹æ„å‘³ç€ä¸å¹²æ´»ï¼Œä½†æ˜¯ä¼šä¸æ–­æ£€æŸ¥æœ‰æ²¡æœ‰æ´»å¯ä»¥å¹²ï¼Œæ˜¯ä¸€ä¸ªä¸æ–­è€—cpuçš„çŠ¶æ€ï¼Œä½†è€—æ—¶æçŸ­ï¼Œå¯èƒ½åªæœ‰ä¸€ç¬é—´å¤„äºè‡ªæ—‹ã€‚åœ¨è‡ªæ—‹è¿™ä¸ªçª—å£æœŸå†…ï¼Œå…¶ä»–å¹¶å‘çš„çº¿ç¨‹é€šè¿‡æ£€æŸ¥æœ‰æ²¡æœ‰çº¿ç¨‹å¤„äºè‡ªæ—‹çŠ¶æ€ï¼Œä»¥é¿å…å…¶å¯åŠ¨ä¸å¿…è¦çš„çº¿ç¨‹ã€‚

æ€»çš„æ¥è¯´å°±æ˜¯æŒ‰ç…§ä¼˜å…ˆçº§ä»å‡ ä¸ªåœ°æ–¹è·å–gï¼š

- æœ¬åœ°é˜Ÿåˆ—ï¼ˆæ¯60æ¬¡è°ƒåº¦ä¼šä¼˜å…ˆä»å…¨å±€é˜Ÿåˆ—è·å–gï¼Œé¿å…å…¨å±€é˜Ÿåˆ—çš„gé¥¥é¥¿ï¼‰
- å…¨å±€é˜Ÿåˆ—
- netpoller
- work-stealingï¼ˆä»å…¶ä»–pçš„æœ¬åœ°é˜Ÿåˆ—å·ï¼‰

## runtime.gopark / runtime.goready

channelã€netpollerç­‰éƒ½æ˜¯åŸºäºgmpæ¥è¿›è¡Œé˜»å¡å’Œè°ƒåº¦è¿è¡Œçš„ï¼Œchannelå°±ä¸å¤šè¯´äº†ï¼Œä¹‹å‰åˆ†æchannelçš„æ—¶å€™ï¼Œnetpolleré€šè¿‡è®¾ç½®éé˜»å¡æ¨¡å¼ï¼Œå°†æœ¬æ¥åº”è¯¥é˜»å¡ç³»ç»Ÿçº¿ç¨‹å˜æˆäº†é˜»å¡gï¼Œå¤§å¤§é™ä½äº†ä¸Šä¸‹æ–‡åˆ‡æ¢æˆæœ¬å’Œæé«˜äº†ç³»ç»Ÿçº¿ç¨‹çš„åˆ©ç”¨ç‡ã€‚

è€Œçº¿ç¨‹å°±ä¸€ç›´ä¸ä¼šé˜»å¡å—ï¼Ÿä¸æ˜¯çš„ï¼Œ`runtime.findrunnable`åœ¨æ‰¾ä¸åˆ°å¯è¿è¡Œçš„gçš„æ—¶å€™ï¼Œå°±ä½¿ç”¨äº†`runtime.stopm`æ¥é˜»å¡mï¼Œåœ¨linuxå¹³å°ä¸Šå…¶å†…éƒ¨æ˜¯é€šè¿‡futexå®ç°çš„ç³»ç»Ÿçº¿ç¨‹é˜»å¡çš„ã€‚

å¦å¤–ï¼Œ`runtime.gopark`æ˜¯å‡ ç§è§¦å‘è°ƒåº¦æ–¹å¼çš„å…¶ä¸­ä¸€ç§ï¼Œå±äºä¸»åŠ¨æŒ‚èµ·ã€‚ä¹‹å‰è¿˜è¯´åˆ°è°ƒåº¦å¾ªç¯å¯åŠ¨çš„`runtime.mstart`ä»¥åŠgè¿è¡Œç»“æŸåçš„`runtime.goexit`ä¹Ÿä¼šè§¦å‘è°ƒåº¦ã€‚

```go
func gopark(unlockf func(*g, unsafe.Pointer) bool, lock unsafe.Pointer, reason waitReason, traceReason traceBlockReason, traceskip int) {
	if reason != waitReasonSleep {
		checkTimeouts() // timeouts may expire while two goroutines keep the scheduler busy
	}
	mp := acquirem()
	gp := mp.curg
	status := readgstatus(gp)
	if status != _Grunning && status != _Gscanrunning {
		throw("gopark: bad g status")
	}
	mp.waitlock = lock
	mp.waitunlockf = unlockf
	gp.waitreason = reason
	mp.waitTraceBlockReason = traceReason
	mp.waitTraceSkip = traceskip
	releasem(mp)
	// åˆ‡æ¢åˆ°g0ï¼Œè°ƒç”¨runtime.park_m
	mcall(park_m)
}

func park_m(gp *g) {
	...

    // è®¾ç½®gçš„çŠ¶æ€ä¸º_Gwaitingï¼Œè§£ç»‘må’Œg
	casgstatus(gp, _Grunning, _Gwaiting)
	dropg()

    // è°ƒç”¨goparkä¼ å…¥çš„å›è°ƒå‡½æ•°ï¼Œè¿”å›falseä»£è¡¨å¤–ç•Œä¸æƒ³é˜»å¡äº†ï¼Œäºæ˜¯ä¼šç»§ç»­æ‰§è¡Œgï¼Œä¸ä¼šé˜»å¡
	if fn := mp.waitunlockf; fn != nil {
		ok := fn(gp, mp.waitlock)
		mp.waitunlockf = nil
		mp.waitlock = nil
		if !ok {
			if traceEnabled() {
				traceGoUnpark(gp, 2)
			}
			casgstatus(gp, _Gwaiting, _Grunnable)
			execute(gp, true) // Schedule it back, never returns.
		}
	}
    
    // è§¦å‘è°ƒåº¦å…¶ä»–g
	schedule()
}
```

å†æ¥çœ‹ä¸‹`runtime.goready`ï¼Œå’Œ`runtime.gopark`æœ¬è´¨ä¸Šéƒ½æ˜¯å°†gçš„çŠ¶æ€æ”¹æˆrunnableæˆ–è€…waitingï¼Œç„¶åè®©è°ƒåº¦å™¨å»è°ƒåº¦å¯è¿è¡Œçš„gï¼š

```go
func goready(gp *g, traceskip int) {
    // åˆ‡æ¢åˆ°ç³»ç»Ÿæ ˆä¸Šæ‰§è¡Œï¼Œ
	systemstack(func() {
		ready(gp, traceskip, true)
	})
}

func ready(gp *g, traceskip int, next bool) {
	...

	// å°†gçš„çŠ¶æ€è®¾æˆå¯è¿è¡Œï¼Œæ”¾åˆ°é˜Ÿåˆ—ä¸­ï¼Œå”¤é†’pï¼Œç­‰å¾…ä¸‹ä¸€æ¬¡è°ƒåº¦
	casgstatus(gp, _Gwaiting, _Grunnable)
	runqput(mp.p.ptr(), gp, next)
	wakep()
	releasem(mp)
}
```

æ³¨æ„`runtime.gopark`ä½¿ç”¨`runtime.mcall`åˆ‡æ¢åˆ°g0æ‰§è¡Œï¼Œæ‰€æ‰§è¡Œçš„å‡½æ•°æ˜¯ä¸ä¼šè¿”å›çš„ã€‚è€Œ`runtime.goready`ä½¿ç”¨çš„æ˜¯`runtime.systemstack`åˆ‡æ¢åˆ°ç³»ç»Ÿæ ˆæ‰§è¡Œä¸€æ®µä»£ç ï¼Œç„¶åè¿”å›åˆ°å½“å‰gç»§ç»­æ‰§è¡Œã€‚

## runtime.sysmon

åœ¨ç¨‹åºå¯åŠ¨çš„æ—¶å€™ï¼Œä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„çº¿ç¨‹mï¼ŒåŒæ—¶åˆ›å»ºä¸€ä¸ªåç¨‹gï¼Œè¿™ä¸ªgä¸éœ€è¦ç»‘å®špï¼Œç›´æ¥ä¸mç»‘å®šï¼Œä¹Ÿå°±æ˜¯æ‰€è°“çš„sysmonåç¨‹ï¼Œsysmonå……å½“ä¸€ä¸ªå®ˆæŠ¤è¿›ç¨‹çš„è§’è‰²ï¼Œæ¯”å¦‚ä¼šåšæ£€æŸ¥æ­»é”ã€è½®è¯¢ç½‘ç»œã€æŠ¢å é•¿æœŸè¿è¡Œæˆ–è€…å¤„äºç³»ç»Ÿè°ƒç”¨çš„ Goroutineã€è§¦å‘åƒåœ¾å›æ”¶ç­‰æ“ä½œï¼ŒååŠ©ç³»ç»Ÿçš„è¿è¡Œã€‚

```go
func main() {
	...
	if GOARCH != "wasm" { // no threads on wasm yet, so no sysmon
		atomic.Store(&sched.sysmonStarting, 1)
        // ç›´æ¥è°ƒç”¨newmå¯åŠ¨çº¿ç¨‹æ‰§è¡Œsysmonï¼Œä¸éœ€è¦p
		systemstack(func() {
			newm(sysmon, nil, -1)
		})
	}
	...
}
```

sysmonè¿è¡Œåœ¨ä¸€ä¸ªæ— é™å¾ªç¯ä¸­ï¼Œæ¯æ¬¡å¾ªç¯çš„å¼€å§‹ä¼š`runtime.usleep`ä¸»åŠ¨ä¼‘çœ ä¸€ä¼šï¼Œå¦‚æœæŠ¢å  P å’Œ G å¤±è´¥æ¬¡æ•°è¶…è¿‡50è½®ã€ä¸”æ²¡æœ‰è§¦å‘ GCï¼Œåˆ™è¯´æ˜å¾ˆé—²ï¼Œç¿»å€ä¼‘çœ ï¼Œæœ€å¤š10msã€‚

```go
func sysmon() {
	lock(&sched.lock)
	sched.nmsys++
    // æ£€æŸ¥æ­»é”
	checkdead()
	unlock(&sched.lock)

	lasttrace := int64(0)
	idle := 0 // how many cycles in succession we had not wokeup somebody
	delay := uint32(0)

	for {
		if idle == 0 { // start with 20us sleep...
			delay = 20
		} else if idle > 50 { // start doubling the sleep after 1ms...
			delay *= 2
		}
		if delay > 10*1000 { // up to 10ms
			delay = 10 * 1000
		}
		usleep(delay)

        ...

		lock(&sched.sysmonlock)
		now = nanotime()

		...
        
		// å¦‚æœè¶…è¿‡10msæ²¡æœ‰pollç½‘ç»œï¼Œpollä¸€ä¸‹
		lastpoll := sched.lastpoll.Load()
		if netpollinited() && lastpoll != 0 && lastpoll+10*1000*1000 < now {
			sched.lastpoll.CompareAndSwap(lastpoll, now)
			list := netpoll(0) // non-blocking - returns list of goroutines
			if !list.empty() {
				// pollåˆ°gäº†ï¼Œæ”¾åˆ°å…¨å±€é˜Ÿåˆ—
				incidlelocked(-1)
				injectglist(&list)
				incidlelocked(1)
			}
		}
		...
        
		// æŠ¢å å¤„äºç³»ç»Ÿè°ƒç”¨çš„mä¸Šçš„pï¼Œä»¥åŠæŠ¢å é•¿æ—¶é—´è¿è¡Œçš„g
		if retake(now) != 0 {
			idle = 0
		} else {
			idle++
		}
		
        // æ£€æŸ¥æ˜¯å¦è¦gcï¼Œè¦çš„è¯å°±å°†gc workeråŠ å…¥å…¨å±€é˜Ÿåˆ—
		if t := (gcTrigger{kind: gcTriggerTime, now: now}); t.test() && forcegc.idle.Load() {
			lock(&forcegc.lock)
			forcegc.idle.Store(false)
			var list gList
			list.push(forcegc.g)
			injectglist(&list)
			unlock(&forcegc.lock)
		}
		
        ...
	}
}
```

`runtime.retake`å®ç°äº†gçš„æŠ¢å ã€pä½¿ç”¨æƒçš„è®©å‡ºï¼Œé¿å…åŒä¸€ä¸ªgå ç”¨çº¿ç¨‹æ—¶é—´è¿‡é•¿é€ æˆé¥¥é¥¿

```go
func retake(now int64) uint32 {
	n := 0
	
    ...
    
	for i := 0; i < len(allp); i++ {
		pp := allp[i]
		...
        
		pd := &pp.sysmontick
		s := pp.status
		sysretake := false
		if s == _Prunning || s == _Psyscall {
			// Preempt G if it's running for too long.
			t := int64(pp.schedtick)
			if int64(pd.schedtick) != t {
				pd.schedtick = uint32(t)
				pd.schedwhen = now
			} else if pd.schedwhen+forcePreemptNS <= now {
                // å¦‚æœgå¤„äºè¿è¡Œæˆ–è€…ç³»ç»Ÿè°ƒç”¨è¶…è¿‡10msï¼Œå°±æŠ¢å mï¼Œè®©må»è°ƒåº¦å…¶ä»–çš„g
				preemptone(pp)
				sysretake = true
			}
		}
        
        // pæœ¬åœ°é˜Ÿåˆ—ä¸ä¸ºç©ºæˆ–è€…æ²¡æœ‰ç©ºé—²pï¼Œæˆ–è€…ç³»ç»Ÿè°ƒç”¨è¶…è¿‡10msï¼Œå°±ä½¿ç”¨runtime.handoffè®©å‡ºpä½¿ç”¨æƒï¼Œè®©på»ç»‘å®šå…¶ä»–mï¼Œè®©pä¸­çš„gå¾—ä»¥ç»§ç»­è°ƒåº¦
		if s == _Psyscall {
			// Retake P from syscall if it's there for more than 1 sysmon tick (at least 20us).
			t := int64(pp.syscalltick)
			if !sysretake && int64(pd.syscalltick) != t {
				pd.syscalltick = uint32(t)
				pd.syscallwhen = now
				continue
			}
			// On the one hand we don't want to retake Ps if there is no other work to do,
			// but on the other hand we want to retake them eventually
			// because they can prevent the sysmon thread from deep sleep.
			if runqempty(pp) && sched.nmspinning.Load()+sched.npidle.Load() > 0 && pd.syscallwhen+10*1000*1000 > now {
				continue
			}
			// Drop allpLock so we can take sched.lock.
			unlock(&allpLock)
			// Need to decrement number of idle locked M's
			// (pretending that one more is running) before the CAS.
			// Otherwise the M from which we retake can exit the syscall,
			// increment nmidle and report deadlock.
			incidlelocked(-1)
			if atomic.Cas(&pp.status, s, _Pidle) {
				if traceEnabled() {
					traceGoSysBlock(pp)
					traceProcStop(pp)
				}
				n++
				pp.syscalltick++
				handoffp(pp)
			}
			incidlelocked(1)
			lock(&allpLock)
		}
	}
	unlock(&allpLock)
    
    // è¿”å›è¢«æŠ¢å pçš„æ•°é‡
	return uint32(n)
}
```

## å¸¸è§é¢è¯•é¢˜

### GMPä¸ºä»€ä¹ˆè¦æœ‰P

å¦‚æœæ²¡æœ‰Pï¼Œå³GMæ¨¡å‹ã€‚goç¡®å®ç»å†è¿‡GMæ¨¡å‹ï¼Œåæ¥å¤§ç¥æå‡ºäº†è¿™ä¸ªæ¨¡å‹å­˜åœ¨çš„é—®é¢˜ï¼š

- å•ä¸€çš„gå…¨å±€é˜Ÿåˆ—ï¼Œå¯¼è‡´é”ç«äº‰ä¸¥é‡
- mä¹‹é—´ç»å¸¸äº¤æ¥å¯è¿è¡Œçš„gï¼Œå¯¼è‡´å»¶è¿Ÿå¢åŠ å’Œé¢å¤–å¼€é”€
- æ¯ä¸ªméƒ½éœ€è¦åšå†…å­˜ç¼“å­˜mcacheï¼Œå¯¼è‡´æ•°æ®å±€éƒ¨æ€§å·®
- ç³»ç»Ÿè°ƒç”¨é¢‘ç¹é˜»å¡å’Œå”¤é†’çº¿ç¨‹ï¼Œå¢åŠ å¼€é”€

## å‚è€ƒé“¾æ¥ğŸ”—

[ã€å¹¼éºŸå®éªŒå®¤ã€‘Golangåˆè¾‘](https://www.bilibili.com/video/BV1hv411x7we/?p=4&share_source=copy_web&vd_source=c0d41b92058c38bc23233feb8c73c581)

[ã€dravenessã€‘é¢å‘ä¿¡ä»°ç¼–ç¨‹](https://draveness.me/golang/)

[ã€å°å¾å…ˆç”Ÿ1212ã€‘è§£è¯´Golang GMP å®ç°åŸç†](https://www.bilibili.com/video/BV1oT411Y7m3/)

[ã€lunar@qq.comã€‘Golang 1.21.4 GMPè°ƒåº¦å™¨åº•å±‚å®ç°ä¸ªäººèµ°è¯»](https://blog.csdn.net/qq_58339096/article/details/134350312)

[ã€panjf2000ã€‘Go ç½‘ç»œæ¨¡å‹ netpoll å…¨æ­ç§˜](https://strikefreedom.top/archives/go-netpoll-io-multiplexing-reactor)

[ã€boyaã€‘æ·±å…¥golang runtimeçš„è°ƒåº¦](https://zboya.github.io/post/go_scheduler)

[ã€stack overflowã€‘Benefits of runtime.LockOSThread in Golang](https://stackoverflow.com/questions/25361831/benefits-of-runtime-lockosthread-in-golang)

[ã€Dmitry Vyukovã€‘Scalable Go Scheduler Design Doc](https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit?pli=1#heading=h.mmq8lm48qfcw)

[ã€æ¬§é•¿å¤ã€‘Goè¯­è¨€åŸæœ¬](https://golang.design/under-the-hood/)