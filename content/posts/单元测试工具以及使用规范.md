---
date: 2026-01-03T23:13:11+08:00
title: 单元测试工具以及使用规范
tags: [unit-test]
categories: [unit-test]
draft: true
---

# 单元测试工具以及使用规范

本文讲述单元测试工具的使用以及使用规范，聚焦于“规范”，而不是罗列测试工具的所有功能。

> [!tip]
>
> 测试工具比如 ginkgo 提供了许多看起来很 fancy 很有用的功能，比如各种装饰器、`GinkGoHelper` 等，但它们同时也增加了别人对代码的理解成本，请遵循 KISS 原则，切勿滥用。

[toc]

## 单元测试工具

- Ginkgo（测试框架）：用于组织测试用例的结构、生命周期、执行与报告。提供并发测试、随机顺序等功能。
- Gomega（断言库）：用于断言测试的实际值与期望值是否匹配，提供各种类型的断言、异步断言等功能。
- testify/mock（mock 库）：用于运行时局部替换类方法的实现。
- mockery（mock codegen cli 工具）：用于生成 testify 风格的 mock 类代码，省去自己手写的麻烦。
- Gomonkey（mock 库）：用于运行时全局替换类方法/函数的实现。非必要不使用，仅针对全局函数、第三方函数、没有接口的类等场景。

其中，Ginkgo + Gomega 让我们能以 DSL 的形式编写测试用例。testify 本身包含了断言和 mock，为了统一风格，对于断言我们仅使用 Gomega 进行断言，而 mock 则交给 testify/mock 和 Gomonkey。

## 如何保证各 UT 之间互不影响

1. **避免使用 gomonkey**：因为用它来打桩的影响周期是整个程序运行时。比如你在某个 UT 内对一个全局函数进行打桩，那么当当前 UT 结束后继续运行下一个 UT 时，这个桩依然存在，此时会影响下一个 UT 的测试。其次，gomonkey 依赖于 runtime hack，简单来说依赖于 go 版本，可能在下个版本就会出现各种 bug。

   避免使用 gomonkey 的根本方法是设计良好的生产代码，避免使用全局类、尽量将外部依赖功能封装在类方法中（比如数据库调用、socket 调用）、对于每个类都尽可能地抽象出接口，并使用依赖注入，面向接口编程。这样一来，既增强了生产代码的可扩展性，也便于写出高质量的 UT。

2. **避免在测试文件中使用全局变量**：将变量的可见性限定在某个上下文中，比如 ginkgo 的容器节点内，下面会说到。

## ginkgo 引入的概念

- **容器节点（container nodes）**：比如 Describe、Context。用于将测试用例进行分组、增加上下文说明，增强整个项目这么多 UT 的可维护性/可读性。换句话说，就算你不遵循规范，将所有测试用例通通塞到一个容器节点里也不会对测试结果有任何影响。
- **设置节点（setup nodes）**：比如 BeforeEach、AfterEach。用于在测试节点前后、suite 前后等做一些初始化/收尾工作。类似 Java Junit 中的由 `@BeforeEach`、`@AfterEach` 注解的函数。
- **测试节点（subject nodes）**：比如 It、Specify。一个测试节点就是一个测试用例/测试场景。当然你不遵循规范的话，也可以将所有测试场景全部塞到一个测试节点中。

对于一个容器节点的所有 UT 都使用到的公共变量，遵循规范的做法是：在容器节点中声明变量，在设置节点中初始化变量，在测试节点中使用变量

如果你发现你在一个 UT 中出现了 “给变量设置某个值、测试函数 A、得到测试结果、设置下一个值、测试函数 B....”，那你应该考虑把这个 UT 拆分成多个 UT，每个 UT 的只进行一次“给变量设置某个值、测试函数 A、得到测试结果”。

举个例子：

``` go
var _ = Describe("Books", func() {
  // 在容器节点中声明变量
  var foxInSocks, lesMis *books.Book

  BeforeEach(func() {
    // 在设置节点中初始化变量
    lesMis = &books.Book{
      Title:  "Les Miserables",
      Author: "Victor Hugo",
      Pages:  2783,
    }

    foxInSocks = &books.Book{
      Title:  "Fox In Socks",
      Author: "Dr. Seuss",
      Pages:  24,
    }
  })

  Describe("Categorizing books", func() {
    Context("with more than 300 pages", func() {
      It("should be a novel", func() {
        // 在测试节点中使用变量
        Expect(lesMis.Category()).To(Equal(books.CategoryNovel))
      })
    })

    Context("with fewer than 300 pages", func() {
      It("should be a short story", func() {
        Expect(foxInSocks.Category()).To(Equal(books.CategoryShortStory))
      })
    })
  })
})
```

ginkgo 还有一个概念叫 spec，在我看来其实 spec = 测试节点 = 测试用例。之所以提一下 spec 这个概念是因为在运行测试的时候，上面的例子结果打印是这样的：

``` bash
Running Suite: Books Suite - path/to/books
==========================================================
Random Seed: 1634748172

Will run 2 of 2 specs
••

Ran 2 of 2 Specs in 0.000 seconds
SUCCESS! -- 2 Passed | 0 Failed | 0 Pending | 0 Skipped
PASS

Ginkgo ran 1 suite in Xs
Test Suite Passed
```

例子中有两个测试节点，所以最终运行结果显示有两个 spec。

### 使用容器节点来组织测试用例

ginkgo 有三种容器节点：`Describe`、`Context`、`When`，它们是各自的别名，只是在语义上有差别，`Describe` 用于描述“这些是 XX 类/功能的测试”、`Context` 用于描述“这些是 XX 场景下的测试”、`When` 用于描述“这些是当 XX 发生时的测试”。（其实只用 `Describe` 和 `Context` 就足够了）

另外，容器节点还会将其包含的设置节点只作用于同一容器节点内的测试节点上，不会作用到其它容器节点内的测试节点。

## 开始使用 ginkgo

参考 [官方教程](https://onsi.github.io/ginkgo/#installing-ginkgo)：

1. 安装 gogink cli 工具，用于生成 suite 的初始模板代码（不想安装完全手写也可以，代码量并不多）

2. （每个包只执行一次）在待测试包下执行 `ginkgo bootstrap` 生成 suite 入口，文件名为 `PACKAGE_suite_test.go`，生成得到的内容如下：

   ``` go
   package books_test
   
   import (
     . "github.com/onsi/ginkgo/v2"
     . "github.com/onsi/gomega"
     "testing"
   )
   
   func TestBooks(t *testing.T) {
     // 设置gomega断言失败的处理函数为Fail，用于断言失败时报告当前UT失败，并自动开始下一个UT
     RegisterFailHandler(Fail)
     // 逐个运行当前包下的所有spec
     RunSpecs(t, "Books Suite")
   }
   ```

3. （每个包根据实际情况执行多次）在 suite 同目录下执行不同的 `ginkgo generate <SUBJECT>` 生成测试文件，文件名为 `SUBJECT_test.go`，内容如下：

   ``` go
   package books_test
   
   import (
     . "github.com/onsi/ginkgo/v2"
     . "github.com/onsi/gomega"
   
     "path/to/books"
   )
   
   var _ = Describe("Books", func() {
   // 待添加测试节点
   })
   ```

## 在 UT 中日志打印

> [!TIP]
>
> 使用 `GinkgoWriter` 来打印日志

ginkgo 提供了全局变量 `GinkgoWriter` 用来给我们打印日志，它的输出格式与 `fmt` 一样，没有其它修饰（比如时间戳、行数等）。日志只有在 UT 失败时才会被打印（ginkgo 能感知哪些日志属于哪些 UT），比如：

``` go
var _ = Describe("V1", func() {
    It("test goroutine", func() {
      	// 这行会被打印
        GinkgoWriter.Println("hi from goroutine 1")
        Fail("oh no")

    })
    It("test goroutine 2", func() {
      	// 这行不会被打印
        GinkgoWriter.Print("hi from goroutine 2")
      	// 这行会被打印，因为使用了原生的fmt
        fmt.Println("hi")
    })
})
```

如果你希望打印的日志与生产代码的风格统一，`GinkgoWriter` 本身实现了 `io.Writer`，因此你可以很方便地将它包装到你自己的日志类中，将输出重定向到 `GinkgoWriter` 即可。

最后，执行 `ginkgo -v` 无论 UT 是否成功都一律打印日志。

## 在 UT 中的子协程断言

> [!TIP]
>
> 使用 `GinkgoRecover` 在子协程中处理断言失败

在测试节点/设置节点中断言失败会回调我们在 suite 开始时注册的 `Fail` 函数，ginkgo 会感知到并将当前 UT 的结果置为失败，并开始下一个 UT。但如果你是在子协程中断言失败，会直接导致整个测试进程结束，而不是只让当前 UT 结束，比如：

``` go
func TestV1(t *testing.T) {
    RegisterFailHandler(Fail)
    RunSpecs(t, "V1 Suite")
}

var _ = Describe("V1", func() {
    It("test goroutine", func() {
        go func() {
          	// 这将导致整个进程结束
            Fail("This should never happen")
        }()
        <-time.After(time.Second * 3)
    })
    It("test goroutine 2", func() {
        fmt.Println("hi")
    })
})
```

但 goroutine 中的代码本质上还是属于当前的 UT，因此我们希望当 go 协程中断言失败时的预期行为与主协程断言失败一样：当前 UT 结果置为失败，并进行下一个 UT。因此，需要在可能会断言失败的子协程的开头加上一行 `defer GinkgoRecover()`，这样就能让 ginkgo 正确地置当前 UT 失败：

``` go
go func() {
	defer GinkgoRecover()
  Fail("This should never happen")
}()
```

## table-driven 风格的 UT

> [!TIP]
>
> 优先考虑将 UT 写成 table-driven 风格

table-driven 使用 `DescribeTable` 节点实现，table-driven 目的是减少没必要的代码重复，并且增强测试可读性，直接看一个例子：

```go
Describe("book", func() {
  var book *books.Book

  BeforeEach(func() {
    book = &books.Book{
      Title: "Les Miserables",
      Author: "Victor Hugo",
      Pages: 2783,
    }
    Expect(book.IsValid()).To(BeTrue())
  })

  DescribeTable("Extracting the author's first and last name",
    func(author string, isValid bool, firstName string, lastName string) {
      book.Author = author
      Expect(book.IsValid()).To(Equal(isValid))
      Expect(book.AuthorFirstName()).To(Equal(firstName))
      Expect(book.AuthorLastName()).To(Equal(lastName))
    },
    Entry("When author has both names", "Victor Hugo", true, "Victor", "Hugo"),
    Entry("When author has one name", "Hugo", true, "", "Hugo"),
    Entry("When author has a middle name", "Victor Marie Hugo", true, "Victor", "Hugo"),
  )
})
```

每个 `Entry` 里的数据会当作参数传入函数中，执行相同的逻辑（`BeforeEach` 会作用到每个 `Entry` 上）。比起自己写 for 循环更加方便。

当然，你也可以用多个 `It` 来实现，但这样每个 `It` 除了测试数据不同外，代码逻辑一模一样，造成重复。因此推荐使用 table-driven 风格编写测试。

## UT 的随机数种子

> [!TIP]
>
> 使用 `GinkgoRandomSeed` 作为种子设置我们的随机数生成器

ginkgo 会为每次运行生成一个随机数种子，并在测试开始时打印出来，比如：

``` bash
Random Seed: 1634748172
```

我们可以在代码中通过 `GinkgoRandomSeed` 获取这个种子的值，并将其作为我们随机数生成器的种子。这样的好处在于，当测试失败的时候，下次运行时加上 `--seed=1634748172` 选项将种子指定为上次种子，来稳定地复现失败结果。

其次，ginkgo 也会依赖这个种子将 UT 的运行顺序打乱，打乱 UT 顺序有助于发现我们是否破坏了测试用例之间的独立性。因此将种子固定，能让 UT 运行顺序与上次相同，来稳定地复现失败结果。

## UT 的并行化运行

> [!TIP]
>
> 使用 `ginkgo -p` 并行运行 UT，以提升运行效率以及发现 UT 间的依赖

ginkgo 默认串行运行所有 UT，为了提升测试程序的运行效率（尤其是 CI 的时候），ginkgo 支持 UT 粒度的并行运行，使用 `ginkgo -p` 根据机器核数自动确定并行度，或者 `ginkgo -procs=N` 手动指定并行度。

注意，ginkgo 是通过多进程来实现并行的，在单个进程内依然是串行，所以不用担心 UT 之间会并行读写同一个变量。

## 指定运行某个 UT

> [!TIP]
>
> 使用 `Focus` 装饰器指定只运行某些 UT

使用 `ginkgo` 命令运行测试用例，实际上是 ginkgo 帮我们调用 `go test`。go test 只会调用 `TestXXX(t *testing.T)` 这些测试函数，但使用 ginkgo 编写的测试只有一个测试函数入口作为 suite 的入口，形如：

``` go
func TestBooks(t *testing.T) {
  RegisterFailHandler(Fail)
  RunSpecs(t, "funcs suite")
}

var _ = Describe("func1", func() {
  ...
})

var _ = Describe("func2", func() {
  ...
})
```

因此我们无法只运行其中某些容器节点/测试节点。在实际使用时，我们往往会遇到只有某个 UT 不通过的情况，在下一次运行时我们希望能只运行该 UT。ginkgo 提供了一个 `Focus` 装饰器，只要 suite 中出现 `Focus`，就只会运行由 `Focus` 装饰的容器节点/测试节点（如果没有 `Focus` 就是默认运行所有 UT）。下面的示例中，只会运行 `func1` 里的所有 UT 以及 `it1` 这个 UT

``` go
func TestBooks(t *testing.T) {
  RegisterFailHandler(Fail)
  RunSpecs(t, "funcs suite")
}

var _ = Describe("func1", Focus, func() {
  ...
})

var _ = Describe("func2", func() {
  It("it1", Focus, func() {
    ...
  })
})
```

用完之后手动或者执行命令 `ginkgo unfocus` 来删除这些 `Focus`，不然 CI 的时候就只跑你这几个 UT 了。

## 给 UT 传入 Context

> [!tip]
>
> 不要自己创建 `context.Context`，而是使用 `SpecContext`

如果待测试的方法/函数需要传入一个 `context.Context`，你可以将 `SpecContext` 作为 UT 的第一个参数（ginkgo 会自动注入），然后将它传入你的待测试方法中：

``` go
It("it1", func(ctx SpecContext) {
  db.GetUser(ctx, 1)
})
```

在没有任何超时装饰器的情况下，`SpecContext` 与 `context.Background` 没有区别。如果你设置了超时装饰器比如 `NodeTimeout`，那么 `SpecContext` 超时就会取消，比如：

``` go
It("it1", func(ctx SpecContext) {
  db.GetUser(ctx, 1)
}, NodeTimeout(time.Second))
```

**注意，`SpecContext.Deadline` 方法返回结果永远是 false。但 `Done` 的语义与 `context.Context` 一样，都是超时关闭**

## ginkgo 在 CI 中的最佳实践

参考 https://onsi.github.io/ginkgo/#recommended-continuous-integration-configuration

## 使用断言

以上介绍了使用 ginkgo 如何规范地将 UT 组织起来，下面介绍如何使用 gomega 进行断言。断言分为两类：同步断言与异步断言

``` go
// 同步断言
Expect(ACTUAL). // 返回一个同步断言Assertion
	Should(GomegaMatcher) // 调用Assertion的方法并传入一个匹配器进行断言

// 异步断言
Eventually(ACTUAL). // 返回一个异步断言AsyncAssertion
	Should(GomegaMatcher) // 调用AsyncAssertion的方法并传入一个匹配器进行断言
```

### 等值断言

``` go
Expect(ACTUAL).Should(Equal(EXPECTED))
Expect(ACTUAL).ShouldNot(Equal(EXPECTED))

// 添加断言失败时的说明信息
Expect(ACTUAL).Should(Equal(EXPECTED), "service %s leak", serviceId)
```

### error 断言

```go
err := Foo()
Expect(err).ShouldNot(HaveOccurred())
Expect(err).Should(Succeed()) // 或者写成这样更加简洁

// 注意，官方文档提到了函数有多个返回值+error，并且你只关心 error 是否为空时，可以写成如下形式
Expect(MultiValAndErr()).Error().Should(Succeed())
// 前提是函数的返回值遵循以下 golang 规范才能用：
// 1. error 放在最后一个参数
// 2. error 不为空时，其它返回值均为零值
```

### nil 断言

``` go
var ptr *any
ptr := DoSomething()
Expect(ptr).ToNot(BeNil())
```

### 异步断言

当测试场景为“其它协程、进程甚至外部系统对某个变量进行写入，在 UT 协程中读取该变量并检查是否为预期值”，我们将会用到异步断言（这里说到的变量狭义上可以是内存中的变量，广义上是某个可以读写的值，比如数据库中的某个值）。说白了异步断言的核心就在于变量值不是由当前 UT 协程写入的，因此 UT 协程需要轮询该变量检查是否预期值。

异步断言有两种函数，`Eventually` 和 `Consistently`。他们的区别是在超时时间内：

- `Eventually`：只要出现一次匹配成功就断言成功，全部匹配失败才断言失败
- `Consistently`：只要出现一次匹配失败就断言失败，全部匹配成功才断言成功

#### Eventually

举一个最简单的例子：

```go
status := atomic.Bool{}
func WriteStatus() {
  time.Sleep(100 * time.Millisecond)
  status.Store(true)
}

func ReadStatus() bool {
  return status.Load()
}

var _ = Describe("...", func () {
  go WriteStatus()
  // 阻塞直到 ReadStatus 返回 true
  Eventually(ReadStatus).Should(BeTrue)
})
```

与同步断言不一样的是，异步断言的失败条件是超时。实际上 `Eventually` 有一个超时时间和轮询间隔，分别是 1 秒和 10 毫秒，上面的例子中每 10 毫秒调用一次 `ReadStatus` 检查是否为 true，如果超过 1 秒还没返回 true，该 UT 失败。

我们可以对 `Eventually` 返回的 `AsyncAssertion` 进行配置，例如：

``` go
Eventually(ReadStatus).
	WithPolling(time.Second). // 轮询间隔
  WithTimeout(10 * time.Second). // 超时时长
  Should(BeTrue)
```

我们还能在被轮询的函数内进行同步断言，但是不能用全局的 `Expect` 函数，而是使用传入的 `Gomega` 参数：

``` go
func ReadStatus(g Gomega) bool {
  g.Expect(...).Should(...)
  return status.Load()
}
```

除了对函数进行轮询，还可以对 `chan` 进行断言：

``` go
c := make(chan bool)
go DoStuff(c)
Eventually(c).Should(BeClosed()) // chan关闭则断言成功
Eventually(c).Should(Receive()) // 从chan读到了值则断言成功
Eventually(c).Should(Receive(Equal(true))) // 从chan读到了true则断言成功
var result bool
Eventually(c).Should(Receive(&result)) // 从chan读到了值则断言成功，并将该值赋给变量
```

#### Consistently

使用方法与 `Eventually` 一样，只不过语义不同。

## 使用 testify/mock + mockery 进行 mocking

> [!TIP]
>
> testify/mock 只能用于 mock 那些实现了接口的类

生成 mock 类步骤如下：

1. 首先安装 mockery 命令行工具
2. 在根目录下执行 `mockery init MOD_NAME`（`MOD_NAME` 是整个项目 module 的名字），生成 `.mockery.yaml` 配置文件，并按需修改它的内容
3. 根目录执行 `mockery`，这一步是按照配置文件来生成 mock 文件，里面包含了 mock 类相关代码

比如当前有一个 `UserRepo` 接口：

``` go
package v1

type UserRepo interface {
    Get(id int64) (*User, error)
}

type User struct {
    Name string
}
```

生成得到的 mock 文件内容大致为：

``` go
func NewMockUserRepo(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockUserRepo {
	mock := &MockUserRepo{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

type MockUserRepo struct {
	mock.Mock
}

func (_mock *MockUserRepo) Get(id int64) (*User, error) {
	args := _mock.Called(id)
  return ret.Get(0).(*User), ret.Error(1)
}
```

使用方式：

``` go
var _ = Describe("...", func() {
  It("...", func() {
    // 创建mock对象
    obj := NewMockUserRepo(GinkgoT())
    
    // 使用由mockery生成的，类型安全的EXPECT
    obj.EXPECT().Get(1).Return(&User{"Lucy"}, nil)
    obj.EXPECT().Get(mock.Anything).Return(&User{"Lucy"}, nil)
    // 如果当前mockery版本不支持EXPECT，则使用On
    obj.On("Get", 1).Return(&User{"Lucy"}, nil)
    obj.On("Get", mock.Anything).Return(&User{"Lucy"}, nil)
    
    
    // 将对象传入待测试函数
    result := DoSomething(obj)
    // 断言
    ...
  })
})
```

## 使用 gomonkey 进行 mocking

> [!CAUTION]
>
> 非必要的情况下不要使用 gomonkey，如果发现不得不用的情况，请改造代码，不能改造代码的情况下，记得 Reset。如果是临时使用，用完即删

使用方式参考 [examples](https://github.com/agiledragon/gomonkey/tree/master/test)

## 参考

[ginkgo](https://onsi.github.io/ginkgo)

[gomega](https://onsi.github.io/gomega)

[mockery](https://vektra.github.io/mockery/)
